#!/bin/python

from telethon import TelegramClient, events, tl

from pyfzf.pyfzf import FzfPrompt
from mutagen.id3 import ID3, USLT, TPE1
from bs4 import BeautifulSoup
from pprint import pprint

import configparser
import subprocess
import requests
import asyncio
import urllib
import socket
import json
import time
import sys
import re
import os

Config_Dir = "${HOME}/.config/sdl"

Api_Id = None
Api_Hash = None

Music_Dir = None
Lyrics_Dir = None

MIN_CHUNK_SIZE = 4096
CHUNK_COUNT = 256
REQUEST_SIZE = MIN_CHUNK_SIZE * CHUNK_COUNT

def Logger(msg, level = "LOG"):
    print(msg)

class SpotQuery:

    _re_pat = None
    _fzf = None
    _headers = {"user-agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) QtWebEngine/5.15.3 Chrome/87.0.4280.144 Safari/537.36"}


    def __init__ (self, query):
        if SpotQuery._re_pat is None:
            SpotQuery._re_pat = re.compile("^(https://open\.spotify\.com/(.+)/.{22})(\?)?(.*)$")
        if SpotQuery._fzf is None:
            SpotQuery._fzf = FzfPrompt()
        self.query = query
        self.query_results = None

    def _get_index (self, line):
        end = 0
        for i in range(len(line) - 1):
            if line[i] == " ":
                end = i
                break

        return int(line[0:end])

    def _create_url (self, query):

        new = ""
        for i in query:
            if i == " ":
                new = new + "+"
            else:
                new = new + i
        query = new

        return "https://www.google.com/search?q=" + query + "+spotify&ei=JVlSYtHCA-6MseMPwNGeiAc&ved=0ahUKEwiR6fbF0Ij3AhVuRmwGHcCoB3EQ4dUDCA4&uact=5&oq=" + query + "+spotify&gs_lcp=Cgdnd3Mtd2l6EANKBAhBGABKBAhGGABQAFi1c2C5dmgEcAF4AIAByQGIAfkikgEGMC4zMC4xmAEAoAEBwAEB&sclient=gws-wiz"

    def _refine_link (self, link):

        # only works if we don't pass the headers
        res = requests.get(link["url"])

        if not res.ok:
            Logger("Spotify query failed", "WARN")
            return link

        soup = BeautifulSoup(res.text, "html.parser")

        for meta in soup.find_all("meta"):
            if meta.has_attr("name") and meta["name"] == "twitter:title":
                if meta.has_attr("content") and meta["content"] != "":
                    link["title"] = meta["content"]
                    return link


    def query_from_google (self, query):

        Logger("query_from_google")

        if query is None:
            None

        query_results = []

        url = self._create_url(query)

        res = requests.get(url, headers = self._headers)

        if not res.ok:
            Logger("Google query failed", "WARN")
            return None

        with open("google.html", "w") as f:
            f.write(res.text)

        soup = BeautifulSoup(res.text, "html.parser")

        for h3 in soup.find_all("h3"):
            if h3.parent.has_attr("href"):
                title = h3.text
                mat = self._re_pat.match(h3.parent["href"])

                if mat is None:
                    continue

                groups = mat.groups()

                if groups[1] == "album":
                    res_type = "album"
                elif groups[1] == "track":
                    res_type = "track"
                else:
                    continue

                query_results.append(
                    self._refine_link({
                        "url": groups[0],
                        "type": res_type,
                        "title": title
                    })
                )

        if len(query_results) > 0:
            return query_results
        else:
            return None

    def query_by_album_from_spotify (self, album_url):

        # queries the songs of the album, but not sure whether
        # this will return all of the tracks if the album has a
        # track count larger the 30 songs. This will be usefull
        # to get the albums having a single track.

        query_results = []

        # only works if we don't pass the headers
        res = requests.get(album_url)

        if not res.ok:
            Logger("Spotify query failed", "WARN")
            return None

        soup = BeautifulSoup(res.text, "html.parser")

        for div in soup.find_all("div"):
            if div.has_attr("aria-label"):
                # TODO: make sure this url is actually a track url
                query_results.append({
                    "title": div["aria-label"],
                    "url": re.sub(
                        "^.*track:", "https://open.spotify.com/track/", div["aria-labelledby"]
                    ),
                    "type": "track"
                })

        if len(query_results) > 0:
            return query_results
        else:
            Logger("Got no tracks", "WARN")
            return None

    def _is_in (self, val, lis, key):

        idx = -1

        for i in range(len(lis)):
            if lis[i][key] == val:
                idx = i
                break

        return idx


    def query_by_track_from_spotify (self, track_url, google_results):

        # queries the track from spotify, this hopefully returns
        # the album and the related tracks.

        query_results = []

        # only works if we don't pass the headers
        res = requests.get(track_url)

        if not res.ok:
            Logger("Spotify query failed", "WARN")
            return None

        soup = BeautifulSoup(res.text, "html.parser")

        for div in soup.find_all("div"):
            if div.text[0:6] == "Single":
                parent = div.find_parent()
                if parent.has_attr("href"):
                    Logger("Got a Song")

                    title = None
                    for child in parent.children:
                        if child.has_attr("dir"):
                            title = child.text
                            break
                    if title is None:
                        Logger("Haven't got a title", "WARN")

                    url = "https://open.spotify.com" + parent["href"]
                    url_type = None

                    if parent["href"][0:6] == "/album":
                        Logger("The song has an album url, querying for the track url")
                        url_list = self.query_by_album_from_spotify(url)

                        if url_list is None:
                            Logger("query_by_album_from_spotify() returned nothing", "WARN")

                        idx = self._is_in(url_list[0]["url"], google_results, "url")

                        if idx > -1:
                            Logger("This url is in the google results")
                            if len(google_results[idx]["title"]) < len(url_list[0]["title"]):
                                Logger("New title is bigger than old, so updating")
                                Logger("Old: " + google_results[idx]["title"])
                                Logger("New: " + url_list[0]["title"])
                                google_results[idx]["title"] = url_list[0]["title"]
                            continue

                        if len(url_list) == 1:
                            if url_list[0]["type"] == "track":
                                Logger("Got the track url")
                                url = url_list[0]["url"]
                                url_type = "track"
                            else:
                                Logger("Haven't got a track url, instead got a " + url_list[0]["url"], "WARN")
                        elif len(url_list) > 1:
                            Logger("query_by_album_from_spotify() returned more than one links, merging it with the results")
                            query_results = query_results + url_list
                            continue

                    elif parent["href"][0:6] == "/track":
                        Logger("The song has an track url")
                        url_type = "track"
                    else:
                        Logger("The song neither has a track url or an album url", "WARN")

                    if url is not None and url_type is not None and title is not None:
                        query_results.append({
                            "title": title,
                            "url": url,
                            "type": url_type
                        })
                        print("")
                    else:
                        Logger("One of url, url_type, and title was None", "WARN")


            elif div.text[0:5] == "Album":

                parent = div.find_parent()

                if parent.has_attr("href"):
                    Logger("Got an Ablum")

                    title = None
                    for child in parent.children:
                        if child.has_attr("dir"):
                            title = child.text
                            break
                    if title is None:
                        Logger("Haven't got a title", "WARN")

                    if parent["href"][0:6] == "/album":
                        url_type = "album"
                    else:
                        Logger("url is not a album url", "WARN")
                        url_type = None

                    url = "https://open.spotify.com" + parent["href"]

                    if url is not None and url_type is not None and title is not None:
                        query_results.append({
                            "title": title,
                            "url": url,
                            "type": url_type
                        })
                        print("")
                    else:
                        Logger("One of url, url_type, and title was None", "WARN")

        if len(query_results) > 0:
            return query_results
        else:
            Logger("Got no links", "WARN")
            return None


    def query_from_spotify (self, url, url_type, google_results):

        if url_type == "track":
            return self.query_by_track_from_spotify(url, google_results)
        elif url_type == "ablum":
            return self.query_by_album_from_spotify(url)
        else:
            Logger("Currently only tracks and albums can be queried from spotify", "WARN")
            return None

    def query_links (self, query):

        if query is None:
            return None

        gres = self.query_from_google(query)

        if gres is None:
            return None

        sres = None

        for link in gres:
            if link["type"] == "track":
                print(link["url"])
                sres = self.query_from_spotify(link["url"], link["type"], gres)
                break

        if sres is not None:
            gres = gres + sres

        return gres

    def prompt_user (self, query_list):

        fzf_list = []
        idx = 0


        for res in query_list:
            if res["type"] == "album":
                url_type = "Album"
            elif res["type"] == "track":
                url_type = "Track"
            elif res["type"] == "playlist":
                url_type = "Playlist"
            else:
                url_type = "Umm"
            fzf_list.append(str(idx) + " " + url_type + ": " + res["title"])
            idx = idx + 1

        sel = self._fzf.prompt(fzf_list, "--with-nth 2..")

        if not sel:
            return None

        sel_idx = self._get_index(sel[0])

        return query_list[sel_idx]


    def gen_result (self):

        if self.query_results is None:
            self.query_results = self.query_links(self.query)
            if self.query_results is None:
                Logger("No query results were generated from google", "WARN")
                return None

        self.selected_query_result = self.prompt_user(self.query_results)

        return self.selected_query_result

    def get_url (self, result = None):
        if result is None:
            result = self.selected_query_result
        return result["url"]

    def get_type (self, result = None):
        if result is None:
            result = self.selected_query_result
        return result["type"]

    def get_title (self, result = None):
        if result is None:
            result = self.selected_query_result
        return result["title"]

class SpotDownload:

    client = None

    def __init__ (self, session, api_id, api_hash):
        ### if SpotDownload.client == None:
        ###     SpotDownload.client = TelegramClient(session, api_id, api_hash)
        # Everything that related with downloading files
        self._last_dl_status = None
        self._last_album_track_count = 0
        self._last_album_title = ""
        self._last_album_artist = ""
        self._last_album_dl_count = 0
        self._one_photo_recieved = False
        self._one_track_recieved = False
        self._download_list = None
        self._clicked_button = False
        self._last_dl_files = None
        self._last_playlist_dl_count = 0

        # Everything that relate to daemon
        self._port = 42045
        self._backlog = 5
        self._is_connected = False
        self._dlog_file_path = "daemon.log"
        self._dlog_file_fd = None

    def _set_last_album_info(self, msg_text):

        lend = 0
        lstart = 0

        while msg_text[lend] != "\n":
            lend += 1

        self._last_album_title = msg_text[9:lend]

        lend += 1
        lstart = lend

        while msg_text[lend] != "\n":
            lend += 1

        self._last_album_artist = msg_text[lstart+10:lend]

        lend += 1
        lstart = lend
        while msg_text[lend] != "\n":
            lend += 1
        lend += 1
        lstart = lend

        self._last_album_track_count = int(msg_text[lstart+16:])

    def _curate_files (self):

        if len(self._last_dl_files) < 1:
            Logger("It seems like no files have been downloaded.", "WARN")
            return

        termuxcmd = ["termux-media-scan"]

        subprocess.run(termuxcmd + self._last_dl_files)

    def _to_mb_str_bytes(self, size):
        return "%05.2f MB"%((size / 1024) / 1024)

    def _prog_callback(self, current, total):
        time_taken = time.time() - self._dl_start_time
        speed_kb = "%d KB/s" % (int((current / time_taken) / 1024))
        percent = "% 6.2f%%" % (current / total * 100)
        bars = int((current / total * 100) / 5)
        bar_str = f' {"#"*bars:<20} '

        print(percent + bar_str + speed_kb + " | " + self._to_mb_str_bytes(current) + " / " + self._to_mb_str_bytes(total), end = "\r")

    async def _download_audio (self, msg):

        file_name = ""
        for i in msg.file.name:
            if i == "\"" or i == ":" or i == "?":
                file_name = file_name + " "
            else:
                file_name = file_name + i
        file_name = Music_Dir + "/" + file_name

        if os.path.isfile(file_name):
            Logger("File exists, skipping the download", "WARN")
            return

        self._last_dl_files.append(file_name)

        tmp_file_fd = None
        download_size = 0

        tmp_file_name = Music_Dir + "/" + str(msg.document.id) + ".temp"

        if os.path.isfile(tmp_file_name):
            Logger("Temp file exists, resuming download...")
            tmp_file_fd = open(tmp_file_name, "ab")
            download_size = tmp_file_fd.tell()
            if msg.document.size == download_size:
                Logger("File is already downloaded")
            elif int(download_size / REQUEST_SIZE) * REQUEST_SIZE != download_size:
                Logger(
                    "Temp file size is not a multiple o REQUEST_SIZE\n"
                        + "Request Size: " + str(REQUEST_SIZE)
                        + ", Downloaded Size: " + str(download_size)
                )
        else:
            Logger("Starting a fresh download...")
            tmp_file_fd = open(tmp_file_name, "wb")

        print("File: " + file_name + " | Size: " + self._to_mb_str_bytes(msg.document.size))

        self._dl_start_time = time.time()
        async for chunk in self.client.iter_download(
            msg.document, offset = download_size, request_size = REQUEST_SIZE):
            download_size += len(chunk)
            tmp_file_fd.write(chunk)
            self._prog_callback(download_size, msg.document.size)
        print("")

        tmp_file_fd.close()

        if download_size == msg.document.size:
            os.rename(tmp_file_name, file_name)
        else:
            Logger("Size of the downloaded file doesn't match with the size from Telegram,\nprobably corrupted", "WARN")

    async def _download_audio_files (self):

        print("")
        for msg in self._download_list:
            await self._download_audio(msg)
        print("")

        await self.client.disconnect()

    async def _album_dl_handler (self, event):
        await event.mark_read()
        if event.message.message == "Invalid link ;)":
            Logger("Link was Invalid. Disconnecting...")
            self._last_dl_status = "Failed"
            await self.client.disconnect()

        if event.audio:
            if not self._clicked_button:
                Logger("Directly recieving the tracks")
                self._clicked_button = True

            self._download_list.append(event)
            # await self._download_audio(event)
            self._last_album_dl_count += 1
            if self._last_album_track_count == self._last_album_dl_count and self._one_photo_recieved:
                Logger("Downloaded all the tracks. Disconnecting...")
                self._last_dl_status = "Success"
                Logger("Dettaching album download handler...")
                self.client.remove_event_handler(
                    self._album_dl_handler
                )
                await self._download_audio_files()
            return
        elif event.message.message == "Downloading…":
            Logger("Recived one message with a Downloading…")
            return
        elif event.buttons:

            if self._clicked_button:
                Logger("Got another message with buttons", "WARN")
                return

            # This must be the first msg if the url is a proper one
            self._set_last_album_info(event.message.message)
            Logger("Album Track Count: " + str(self._last_album_track_count))
            Logger("Message has buttons")
            for row in event.buttons:
                for btn in row:
                    if btn.text == "GET ALL ⬇️":
                        Logger("Clicking GET ALL button")
                        self._clicked_button = True
                        await btn.click()
            if not self._clicked_button:
                Logger("Seems like there were no GET ALL button")
                if self._last_album_track_count == 1:
                    Logger("Clicking the first button")
                    self._one_photo_recieved = True
                    self._clicked_button = True
                    await event.buttons[0][0].click()
                else:
                    Logger("Track Count is not 1, somethings wrong", "WARN")

        elif event.photo:
            if not self._clicked_button:
                Logger("Seems like we are recieving tracks directly")
                self._set_last_album_info(event.message.message)
                Logger("Album Track Count: " + str(self._last_album_track_count))
                self._clicked_button = True

            self._one_photo_recieved = True
            Logger("Recived one message with a photo")
            return

    async def _track_dl_handler (self, event):
        await event.mark_read()
        if event.message.message == "Track not found." or event.message.message == "Invalid link ;)":
            if event.message.message == "Track not found.":
                Logger("Track no found. Disconnecting...", "WARN")
            else:
                Logger("Link was Invalid. Disconnecting...", "WARN")
            self._last_dl_status = "Failed"
            await self.client.disconnect()

        if event.audio:
            Logger("Recived one message with an audio")
            self._one_track_recieved = True
            self._download_list.append(event)
            # await self._download_audio(event)

        if event.photo:
            Logger("Recived one message with a photo")
            self._one_photo_recieved = True

        if self._one_photo_recieved and self._one_track_recieved:
            Logger("Recieved the track and the photo. Disconnecting...")
            self._last_dl_status = "Success"
            Logger("Dettaching track download handler...")
            self.client.remove_event_handler(
                self._track_dl_handler
            )
            await self._download_audio_files()

    async def _playlist_dl_handler (self, event):
        await event.mark_read()
        if event.message.message == "Invalid link ;)":
            Logger("Link was Invalid. Disconnecting...")
            self._last_dl_status = "Failed"
            await self.client.disconnect()

        if event.buttons:
            if self._clicked_button:
                Logger("Got another message with buttons.", "WARN")
                if event.message.message == "Downloading…":
                    Logger("Its the Downloading message")
                else:
                    Logger("Its not the Downloading message", "WARN")
                return

            if event.buttons[0][0].text == "GET ALL ⬇️":
                Logger("Clicking GET ALL button")
                self._clicked_button = True
                await event.buttons[0][0].click()
        elif event.audio:
            self._download_list.append(event)
            self._last_playlist_dl_count += 1
        elif event.message.message == "Finished.":
            Logger("Downloaded all the tracks. Disconnecting...")
            self._last_dl_status = "Success"
            Logger("Dettaching playlist download handler...")
            self.client.remove_event_handler(
                self._playlist_dl_handler
            )
            # print(self._last_playlist_dl_count)
            await self._download_audio_files()
        else:
            Logger("Recieved some other message", "WARN")
            print(event.message.message)

    async def _download (self, link_list):

        for link in link_list:
            # TODO: playlist
            link_url = link[0]  # should be a spotify url to a track or an album
            link_type = link[1] # should be Track or Album

            if not self.client.is_connected():
                Logger("Connecting to Telegram...")
                await self.client.connect()
                Logger("Connected to Telegram")

            Logger("Sending the url to deezload2bot")
            await self.client.send_message(
                "deezload2bot", link_url
            )
            if link_type == "album":
                Logger("Attaching album download handler...")
                self.client.add_event_handler(
                    self._album_dl_handler,
                    events.NewMessage(chats = [ 'deezload2bot' ], incoming = True)
                )
                self._last_album_track_count = 0
                self._last_album_title = ""
                self._last_album_artist = ""
                self._last_album_dl_count = 0
                self._clicked_button = False
            elif link_type == "track":
                Logger("Attaching track download handler...")
                self.client.add_event_handler(
                    self._track_dl_handler,
                    events.NewMessage(chats = [ 'deezload2bot' ], incoming = True)
                )
                self._one_track_recieved = False
            elif link_type == "playlist":
                Logger("Attaching playlist download handler...")
                self.client.add_event_handler(
                    self._playlist_dl_handler,
                    events.NewMessage(chats = [ 'deezload2bot' ], incoming = True)
                )
                self._clicked_button = False
                self._last_playlist_dl_count = 0


            self._last_dl_status = None
            self._last_dl_files = []
            self._one_photo_recieved = False
            self._download_list = []

            Logger("Waiting for the reply from deezload2bot...")
            await self.client.run_until_disconnected()

            if self._last_dl_status == "Success":
                Logger("Succeded downloading the file(s)")
                self._curate_files()
            elif self._last_dl_status == "Failed":
                if link_type == "album":
                    Logger("Dettaching track download handler...")
                    self.client.remove_event_handler(
                        self._track_dl_handler
                    )
                elif link_type == "track":
                    Logger("Dettaching album download handler...")
                    self.client.remove_event_handler(
                        self._album_dl_handler
                    )
                elif link_type == "playlist":
                    Logger("Dettaching playlist download handler...")
                    self.client.remove_event_handler(
                        self._playlist_dl_handler
                    )
                Logger("Failed downloading the file(s)", "WARN")
            else:
                Logger("_last_dl_status should be either Success or Failed", "WARN")
                Logger("Current value: " + self._last_dl_status, "WARN")


    def download (self, link_list):

        self.client.start()
        self.client.loop.run_until_complete(self._download(link_list))
        return self._last_dl_files

    def _dlog (self, msg, level = "LOG"):
        self._dlog_file_fd.write(msg + "\n")
        self._dlog_file_fd.flush()
        return

    def _launch (self):

        pid = os.fork()

        if pid == 0: # child

            os.setsid()
            # closing stdin, stdout, and stderr
            for i in [0, 1, 2]:
                try:
                    os.close(i)
                except:
                    pass

            pid = os.fork()

            if pid > 0: # parent, just exit
                exit()
            else: # grand child, do the daemon suff
                self._daemon()

        # TODO: make sure the daemon started succesfully
        return True

    def _d_server_init(self, port, backlog):
        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server.bind((socket.gethostname(), port))
        server.listen(backlog)

        return server

    def _daemon (self):

        if self._dlog_file_fd is None:
            self._dlog_file_fd = open(self._dlog_file_path, "w")
            self._dlog_file_fd.write("Aloha!\n")

        server = self._d_server_init(self._port, self._backlog)
        self._dlog("Started the server")

        self._dlog("Now accepting")
        client, addr = server.accept()
        self._dlog("Got a client")

        self._dlog("Sending hai")
        client.send("hai".encode())
        self._dlog("Now existing")

        return

    def _connect (self):
        pass
        return

    def _is_running (self):
        pass
        return

    def _is_connected (self):
        pass
        return

    def restart (self):
        pass
        return

    # Call this everytime the client starts.
    # And this will take care of starting the daemon
    # (if it's not running) and attaching to the daemon
    def connect (self):

        if self._is_connected:
            return True

        print(self._launch())

        ### if not self._is_running():
        ###     if not self._launch():
        ###         return False

        ### return self._connect()


class SpotLrc():

    _url_base = "https://lrclib.net/api/search?"

    def __init__ (self, lrc_dir):
        if os.path.isdir(lrc_dir):
            self.lrc_dir = lrc_dir
            try:
                os.mkdir(lrc_dir + "/json")
            except FileExistsError:
                pass
            try:
                os.mkdir(lrc_dir + "/lyrics")
            except FileExistsError:
                pass
            try:
                os.mkdir(lrc_dir + "/plain")
            except FileExistsError:
                pass
        else:
            Logger("Directory doesn't exists.")
        pass

    def _fix_artist (self, file):

        artists = file["TPE1"].text[0]
        new_artists = ""
        write = False

        for char in artists:
            if char == "/":
                write = True
                new_artists = new_artists + ","
            else:
                new_artists = new_artists + char

        if write:
            file["TPE1"] = TPE1(text = new_artists)

        return

    def _query_lrclib (self, params):

        synced = None
        plain = None

        url = self._url_base + params
        response = requests.get(url)
        if not response.ok:
            Logger(
                "Got no lrc, response status: " + str(response.status_code)
            )
            return (None, None, None)

        Logger("Got a response...")

        if response.text == "[]":
            return (None, None, None)

        for result in json.loads(response.text):
            if synced is None:
                if result["syncedLyrics"] is not None:
                    Logger("Got a synced lyrics...")
                    synced = re.sub("\] ", "]", result["syncedLyrics"])
            if plain is None:
                if result["plainLyrics"] is not None:
                    Logger("Got a plain lyrics...")
                    plain = result["plainLyrics"]

        return (synced, plain, response)

    def _create_pe_tbl (self, track_name, artist_name, album_name, duration):

        pe_tbl = []

        ####
        param = urllib.parse.urlencode({
            "track_name": track_name,
            "artist_name": artist_name,
            "album_name": album_name,
            "duration": duration
        })

        pe_tbl.append({
            "param": param,
            "error": "Got an empty response, trying again with the track name and artist name..."
        })

        ####
        param = urllib.parse.urlencode({
            "track_name": track_name,
            "artist_name": artist_name,
        })

        pe_tbl.append({
            "param": param,
            "error": "Got an empty response, trying again with the track name and album name..."
        })

        ####
        param = urllib.parse.urlencode({
            "track_name": track_name,
            "album_name": album_name,
        })

        pe_tbl.append({
            "param": param,
            "error": "Got an empty response again, trying again with track name and the cleaned album name..."
        })

        ####
        cleaned_album_name = re.sub("\(( *)?From ?", "", album_name)
        cleaned_album_name = re.sub(" ?\)", "", cleaned_album_name)
        cleaned_album_name = re.sub("[^a-zA-Z0-9 ]", "", cleaned_album_name)

        param = urllib.parse.urlencode({
            "q": track_name + "+" + cleaned_album_name,
        })

        pe_tbl.append({
            "param": param,
            "error": "Got an empty response again, trying again with just the track name..."
        })

        ####
        param = urllib.parse.urlencode({
            "track_name": track_name
        })

        pe_tbl.append({
            "param": param,
            "error": "Still got an empty response, cleaning the title and trying once more..."
        })

        ####
        cleaned_track_name = re.sub(" ?\(.*\) ?", "", track_name)
        cleaned_track_name = re.sub("[^a-zA-Z0-9 ]", "", cleaned_track_name)

        param = urllib.parse.urlencode({
            "track_name": cleaned_track_name
        })

        pe_tbl.append({
            "param": param,
            "error": "Sorry, still got nothing..."
        })

        return pe_tbl

    def _del_uslt_tags (self, file):

        tags_to_del = []

        for key in file.keys():
            if key[0:4] == "USLT":
                tags_to_del.append(key)

        for key in tags_to_del:
            file.pop(key)

    def get_lrc (self, file_list):

        track_name = None
        artist_name = None
        album_name = None
        duration = None

        file_stem = None

        for file_path in file_list:

            file = ID3(file_path)

            file_stem = os.path.splitext(os.path.basename(file_path))[0]

            Logger(file_path)
            Logger("Querying for " + file["TIT2"].text[0] + " - " + file["TPE1"].text[0] + "...")

            Logger("Fixing artists...")
            self._fix_artist(file)
            Logger("Deleting other USLT tags...")
            self._del_uslt_tags(file)

            track_name = file["TIT2"].text[0]
            artist_name = file["TPE1"].text[0]
            album_name = file["TALB"].text[0]
            duration = str(int(int(file["TLEN"].text[0]) / 1000))

            pe_tbl = self._create_pe_tbl(
                track_name,
                artist_name,
                album_name,
                duration
            )

            synced = None
            plain = None
            response = None

            for pe in pe_tbl:
                res = self._query_lrclib(pe["param"])

                if synced is None:
                    synced = res[0]

                if plain is None:
                    plain = res[1]

                response = res[2]
                if synced is None or plain is None:
                    Logger(pe["error"])
                else:
                    break

            if response is not None:
                # TODO: give proper file names instead to slamming file_stem
                with open(self.lrc_dir + "/json/" + file_stem + ".json", "w") as tmp_file:
                    tmp_file.write(response.text)
            else:
                Logger("No response at all, weird...", "WARN")

            if synced is not None:
                file.add(USLT(text = synced, desc = "synced"))
                with open(self.lrc_dir + "/lyrics/" + file_stem + ".lrc", "w") as tmp_file:
                    tmp_file.write(synced)
                    tmp_file.write("\n")
            else:
                Logger("Haven't got the synced lyrics...")

                if plain is not None:
                    file.add(USLT(text = plain, desc = "plain"))

            if plain is not None:
                with open(self.lrc_dir + "/plain/" + file_stem + ".lrc", "w") as tmp_file:
                    tmp_file.write(plain)
                    tmp_file.write("\n")
            else:
                Logger("Haven't got the plain lyrics...")

            file.save()

def parse_config():

    global Config_Dir
    global Music_Dir
    global Lyrics_Dir
    global Api_Id
    global Api_Hash

    Config_Dir = os.path.expandvars(Config_Dir)

    config_file = Config_Dir + "/config.ini"
    if not os.path.isfile(config_file):
        print("Config file is not present: " + config_file)
        print("Inorder to sdl to work, you need the Telegram Api Id and Hash")
        print("Exiting...")
        exit()

    config = configparser.ConfigParser()
    config.read(config_file)

    Music_Dir = os.path.expandvars(config["download"]["MusicDir"])

    if not os.path.isdir(Music_Dir):
        print("Directory doesn't exists: " + Music_Dir)
        print("Please make sure you have specified the right directory to download files.")
        print("Exiting...")
        exit()

    Lyrics_Dir = os.path.expandvars(config["download"]["LyricsDir"])

    if not os.path.isdir(Lyrics_Dir):
        print("Directory doesn't exists: " + Lyrics_Dir)
        print("Please make sure you have specified the right directory to download lyrics.")
        print("Exiting...")
        exit()

    Api_Id = int(config["telegram.api"]["Id"])
    Api_Hash = config["telegram.api"]["Hash"]


def download():

    pat = re.compile("^(https://open\.spotify\.com/([^/]+)/.{22})(\?)?(.*)$")

    query = ""
    downloaded_list = None

    if len(sys.argv) == 2 and (sys.argv[1] == "--clip" or sys.argv[1] == "-c"):
        clip = subprocess.Popen(
            ["termux-clipboard-get"], stdout = subprocess.PIPE
        )

        clip = clip.stdout.read().decode()

        mat = pat.match(clip)

        if mat is not None:

            url_type = None

            grps = mat.groups()

            if grps[1] == "album":
                url_type = "album"
            elif grps[1] == "track":
                url_type = "track"
            elif grps[1] == "playlist":
                url_type = "playlist"
            else:
                Logger("Currently only albums and tracks can be downloaded, exiting...")
                Logger("Clipboard contents: \"" + clip + "\"")
                exit()
        else:
            Logger("Clipboard does not contain a valid url, exiting...")
            Logger("Clipboard contents: \"" + clip + "\"")
            exit()

        sdl = SpotDownload(Config_Dir + "/anon", Api_Id, Api_Hash)
        downloaded_list = sdl.download([(grps[0], url_type)])
    else:
        if len(sys.argv) > 1:

            query = sys.argv[1]

            for arg in sys.argv[2:]:
                query = query + " " + arg
        else:
            print("Query: ", end = "")
            query = input()

        if query == "":
            Logger("No query, exiting...")
            exit()

        squery = SpotQuery(query)

        if squery.gen_result() is None:
            Logger("No selections were generated, exiting...")
            exit()

        sdl = SpotDownload(Config_Dir + "/anon", Api_Id, Api_Hash)
        downloaded_list = sdl.download([(squery.get_url(), squery.get_type())])

    lrc = SpotLrc(Lyrics_Dir)
    lrc.get_lrc(downloaded_list)

    return

# https://open.spotify.com/track/7nHQjVpEncX7NEdA2G6kU1
# https://open.spotify.com/track/7nHQjVpEncX7NEdA2G6kU1


# main()

def attach_lrc ():

    fzf = FzfPrompt()

    files = [file for file in os.listdir(Music_Dir) if file[-4:] == ".mp3"]
    files.sort(key = lambda x: os.path.getmtime(os.path.join(Music_Dir, x)))

    selected = [os.path.join(Music_Dir, file) for file in fzf.prompt(files, "--tac -m")]

    lrc = SpotLrc(Lyrics_Dir)
    lrc.get_lrc(selected)

parse_config()

# sq = SpotQuery("taylor swift songs")
sdl = SpotDownload(Config_Dir + "/anon", Api_Id, Api_Hash)

sdl.connect()

### if len(sys.argv) == 2 and (sys.argv[1] == "--lrc" or sys.argv[1] == "-l"):
###     attach_lrc()
### else:
###     download()

# sdl = SpotDownload(Config_Dir + "/anon", Api_Id, Api_Hash)
# downloaded_list = sdl.download(
#     [("https://open.spotify.com/playlist/2oyDrQfkkSMdyXPXKKHm1t", "playlist")]
# )

# https://open.spotify.com/track/2Fxmhks0bxGSBdJ92vM42m
# lrc = SpotLrc(".")
# lrc.get_lrc(["/data/data/com.termux/files/home/storage/shared/Music/sdl/Emei - Scatterbrain.mp3"])
