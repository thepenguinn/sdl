#!/bin/python

from telethon import TelegramClient, events, tl

from pyfzf.pyfzf import FzfPrompt
from mutagen.id3 import ID3, USLT, TPE1
from bs4 import BeautifulSoup

import configparser
import subprocess
import requests
import asyncio
import urllib
import json
import time
import sys
import re
import os

Config_Dir = "${HOME}/.config/sdl"

Api_Id = None
Api_Hash = None

Music_Dir = None
Lyrics_Dir = None

MIN_CHUNK_SIZE = 4096
CHUNK_COUNT = 256
REQUEST_SIZE = MIN_CHUNK_SIZE * CHUNK_COUNT

def Logger(msg, level = "LOG"):
    print(msg)

class SpotQuery:

    _re_pat = None
    _fzf = None
    _headers = {"user-agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) QtWebEngine/5.15.3 Chrome/87.0.4280.144 Safari/537.36"}



    def __init__ (self, query):
        if SpotQuery._re_pat is None:
            SpotQuery._re_pat = re.compile("^(https://open\.spotify\.com/(.+)/.{22})(\?)?(.*)$")
        if SpotQuery._fzf is None:
            SpotQuery._fzf = FzfPrompt()
        self.query = query
        self.query_results = None

    def _get_index (self, line):
        end = 0
        for i in range(len(line) - 1):
            if line[i] == " ":
                end = i
                break

        return int(line[0:end])

    def _create_url (self, query):

        new = ""
        for i in query:
            if i == " ":
                new = new + "+"
            else:
                new = new + i
        query = new

        return "https://www.google.com/search?q=" + query + "+site%3Aspotify.com&ei=JVlSYtHCA-6MseMPwNGeiAc&ved=0ahUKEwiR6fbF0Ij3AhVuRmwGHcCoB3EQ4dUDCA4&uact=5&oq=" + query + "+site%3Aspotify.com&gs_lcp=Cgdnd3Mtd2l6EANKBAhBGABKBAhGGABQAFi1c2C5dmgEcAF4AIAByQGIAfkikgEGMC4zMC4xmAEAoAEBwAEB&sclient=gws-wiz"

    def query_spotify_links (self, query = None):

        if query:
            self.query = query

        self.query_results = []

        url = self._create_url(query)

        res = requests.get(url, headers = self._headers)

        if not res.ok:
            Logger("Google query failed", "WARN")
            return

        soup = BeautifulSoup(res.text, "html.parser")

        for h3 in soup.find_all("h3"):
            if h3.parent.has_attr("href"):
                title = re.sub("spotify.*", "", h3.parent.text)
                mat = self._re_pat.match(h3.parent["href"])

                if mat is None:
                    continue

                groups = mat.groups()

                if groups[1] == "album":
                    res_type = "Album"
                elif groups[1] == "track":
                    res_type = "Track"
                else:
                    continue

                self.query_results.append({
                    "url": groups[0],
                    "type": res_type,
                    "title": title
                })

        return self.query_results

    def prompt_user (self):

        if not self.query_results:
            self.query_spotify_links(self.query)

        fzf_list = []
        idx = 0

        for res in self.query_results:
            fzf_list.append(str(idx) + " " + res["type"] + ": " + res["title"])
            idx = idx + 1

        sel = self._fzf.prompt(fzf_list, "--with-nth 2..")

        if not sel:
            return None

        sel_idx = self._get_index(sel[0])

        self.selected_query_result = self.query_results[sel_idx]

        return self.selected_query_result

    def gen_result (self):

        if not self.query_results:
            self.query_spotify_links(self.query)

        return self.prompt_user()

    def get_url (self, result = None):
        if result is None:
            result = self.selected_query_result
        return result["url"]

    def get_type (self, result = None):
        if result is None:
            result = self.selected_query_result
        return result["type"]

    def get_title (self, result = None):
        if result is None:
            result = self.selected_query_result
        return result["title"]

class SpotDownload:

    client = None

    def __init__ (self, session, api_id, api_hash):
        if SpotDownload.client == None:
            SpotDownload.client = TelegramClient(session, api_id, api_hash)
        self._last_dl_status = None
        self._last_album_track_count = 0
        self._last_album_title = ""
        self._last_album_artist = ""
        self._last_album_dl_count = 0
        self._one_photo_recieved = False
        self._one_track_recieved = False
        self._download_list = None
        self._clicked_button = False
        self._last_dl_files = None
        self._last_playlist_dl_count = 0

    def _set_last_album_info(self, msg_text):

        lend = 0
        lstart = 0

        while msg_text[lend] != "\n":
            lend += 1

        self._last_album_title = msg_text[9:lend]

        lend += 1
        lstart = lend

        while msg_text[lend] != "\n":
            lend += 1

        self._last_album_artist = msg_text[lstart+10:lend]

        lend += 1
        lstart = lend
        while msg_text[lend] != "\n":
            lend += 1
        lend += 1
        lstart = lend

        self._last_album_track_count = int(msg_text[lstart+16:])

    def _curate_files (self):

        if len(self._last_dl_files) < 1:
            Logger("It seems like no files have been downloaded.", "WARN")
            return

        termuxcmd = ["termux-media-scan"]

        subprocess.run(termuxcmd + self._last_dl_files)

    def _to_mb_str_bytes(self, size):
        return "%05.2f MB"%((size / 1024) / 1024)

    def _prog_callback(self, current, total):
        time_taken = time.time() - self._dl_start_time
        speed_kb = "%d KB/s" % (int((current / time_taken) / 1024))
        percent = "% 6.2f%%" % (current / total * 100)
        bars = int((current / total * 100) / 5)
        bar_str = f' {"#"*bars:<20} '

        print(percent + bar_str + speed_kb + " | " + self._to_mb_str_bytes(current) + " / " + self._to_mb_str_bytes(total), end = "\r")

    async def _download_audio (self, msg):

        file_name = ""
        for i in msg.file.name:
            if i == "\"" or i == ":" or i == "?":
                file_name = file_name + " "
            else:
                file_name = file_name + i
        file_name = Music_Dir + "/" + file_name

        if os.path.isfile(file_name):
            Logger("File exists, skipping the download", "WARN")
            return

        self._last_dl_files.append(file_name)

        tmp_file_fd = None
        download_size = 0

        tmp_file_name = Music_Dir + "/" + str(msg.document.id) + ".temp"

        if os.path.isfile(tmp_file_name):
            Logger("Temp file exists, resuming download...")
            tmp_file_fd = open(tmp_file_name, "ab")
            download_size = tmp_file_fd.tell()
            if msg.document.size == download_size:
                Logger("File is already downloaded")
            elif int(download_size / REQUEST_SIZE) * REQUEST_SIZE != download_size:
                Logger(
                    "Temp file size is not a multiple o REQUEST_SIZE\n"
                        + "Request Size: " + str(REQUEST_SIZE)
                        + ", Downloaded Size: " + str(download_size)
                )
        else:
            Logger("Starting a fresh download...")
            tmp_file_fd = open(tmp_file_name, "wb")

        print("File: " + file_name + " | Size: " + self._to_mb_str_bytes(msg.document.size))

        self._dl_start_time = time.time()
        async for chunk in self.client.iter_download(
            msg.document, offset = download_size, request_size = REQUEST_SIZE):
            download_size += len(chunk)
            tmp_file_fd.write(chunk)
            self._prog_callback(download_size, msg.document.size)
        print("")

        tmp_file_fd.close()

        if download_size == msg.document.size:
            os.rename(tmp_file_name, file_name)
        else:
            Logger("Size of the downloaded file doesn't match with the size from Telegram,\nprobably corrupted", "WARN")

    async def _download_audio_files (self):

        print("")
        for msg in self._download_list:
            await self._download_audio(msg)
        print("")

        await self.client.disconnect()

    async def _album_dl_handler (self, event):
        await event.mark_read()
        if event.message.message == "Invalid link ;)":
            Logger("Link was Invalid. Disconnecting...")
            self._last_dl_status = "Failed"
            await self.client.disconnect()

        if event.audio:
            if not self._clicked_button:
                Logger("Directly recieving the tracks")
                self._clicked_button = True

            self._download_list.append(event)
            # await self._download_audio(event)
            self._last_album_dl_count += 1
            if self._last_album_track_count == self._last_album_dl_count and self._one_photo_recieved:
                Logger("Downloaded all the tracks. Disconnecting...")
                self._last_dl_status = "Success"
                Logger("Dettaching album download handler...")
                self.client.remove_event_handler(
                    self._album_dl_handler
                )
                await self._download_audio_files()
            return
        elif event.message.message == "Downloading…":
            Logger("Recived one message with a Downloading…")
            return
        elif event.buttons:

            if self._clicked_button:
                Logger("Got another message with buttons", "WARN")
                return

            # This must be the first msg if the url is a proper one
            self._set_last_album_info(event.message.message)
            Logger("Album Track Count: " + str(self._last_album_track_count))
            Logger("Message has buttons")
            for row in event.buttons:
                for btn in row:
                    if btn.text == "GET ALL ⬇️":
                        Logger("Clicking GET ALL button")
                        self._clicked_button = True
                        await btn.click()
            if not self._clicked_button:
                Logger("Seems like there were no GET ALL button")
                if self._last_album_track_count == 1:
                    Logger("Clicking the first button")
                    self._one_photo_recieved = True
                    self._clicked_button = True
                    await event.buttons[0][0].click()
                else:
                    Logger("Track Count is not 1, somethings wrong", "WARN")

        elif event.photo:
            if not self._clicked_button:
                Logger("Seems like we are recieving tracks directly")
                self._set_last_album_info(event.message.message)
                Logger("Album Track Count: " + str(self._last_album_track_count))
                self._clicked_button = True

            self._one_photo_recieved = True
            Logger("Recived one message with a photo")
            return

    async def _track_dl_handler (self, event):
        await event.mark_read()
        if event.message.message == "Track not found." or event.message.message == "Invalid link ;)":
            if event.message.message == "Track not found.":
                Logger("Track no found. Disconnecting...", "WARN")
            else:
                Logger("Link was Invalid. Disconnecting...", "WARN")
            self._last_dl_status = "Failed"
            await self.client.disconnect()

        if event.audio:
            Logger("Recived one message with an audio")
            self._one_track_recieved = True
            self._download_list.append(event)
            # await self._download_audio(event)

        if event.photo:
            Logger("Recived one message with a photo")
            self._one_photo_recieved = True

        if self._one_photo_recieved and self._one_track_recieved:
            Logger("Recieved the track and the photo. Disconnecting...")
            self._last_dl_status = "Success"
            Logger("Dettaching track download handler...")
            self.client.remove_event_handler(
                self._track_dl_handler
            )
            await self._download_audio_files()

    async def _playlist_dl_handler (self, event):
        await event.mark_read()
        if event.message.message == "Invalid link ;)":
            Logger("Link was Invalid. Disconnecting...")
            self._last_dl_status = "Failed"
            await self.client.disconnect()

        if event.buttons:
            if self._clicked_button:
                Logger("Got another message with buttons.", "WARN")
                if event.message.message == "Downloading…":
                    Logger("Its the Downloading message")
                else:
                    Logger("Its not the Downloading message", "WARN")
                return

            if event.buttons[0][0].text == "GET ALL ⬇️":
                Logger("Clicking GET ALL button")
                self._clicked_button = True
                await event.buttons[0][0].click()
        elif event.audio:
            self._download_list.append(event)
            self._last_playlist_dl_count += 1
        elif event.message.message == "Finished.":
            Logger("Downloaded all the tracks. Disconnecting...")
            self._last_dl_status = "Success"
            Logger("Dettaching playlist download handler...")
            self.client.remove_event_handler(
                self._playlist_dl_handler
            )
            # print(self._last_playlist_dl_count)
            await self._download_audio_files()
        else:
            Logger("Recieved some other message", "WARN")
            print(event.message.message)

    async def _download (self, link_list):

        for link in link_list:
            # TODO: playlist
            link_url = link[0]  # should be a spotify url to a track or an album
            link_type = link[1] # should be Track or Album

            if not self.client.is_connected():
                Logger("Connecting to Telegram...")
                await self.client.connect()
                Logger("Connected to Telegram")

            Logger("Sending the url to deezload2bot")
            await self.client.send_message(
                "deezload2bot", link_url
            )
            if link_type == "Album":
                Logger("Attaching album download handler...")
                self.client.add_event_handler(
                    self._album_dl_handler,
                    events.NewMessage(chats = [ 'deezload2bot' ], incoming = True)
                )
                self._last_album_track_count = 0
                self._last_album_title = ""
                self._last_album_artist = ""
                self._last_album_dl_count = 0
                self._clicked_button = False
            elif link_type == "Track":
                Logger("Attaching track download handler...")
                self.client.add_event_handler(
                    self._track_dl_handler,
                    events.NewMessage(chats = [ 'deezload2bot' ], incoming = True)
                )
                self._one_track_recieved = False
            elif link_type == "Playlist":
                Logger("Attaching playlist download handler...")
                self.client.add_event_handler(
                    self._playlist_dl_handler,
                    events.NewMessage(chats = [ 'deezload2bot' ], incoming = True)
                )
                self._clicked_button = False
                self._last_playlist_dl_count = 0


            self._last_dl_status = None
            self._last_dl_files = []
            self._one_photo_recieved = False
            self._download_list = []

            Logger("Waiting for the reply from deezload2bot...")
            await self.client.run_until_disconnected()

            if self._last_dl_status == "Success":
                Logger("Succeded downloading the file(s)")
                self._curate_files()
            elif self._last_dl_status == "Failed":
                if link_type == "Album":
                    Logger("Dettaching track download handler...")
                    self.client.remove_event_handler(
                        self._track_dl_handler
                    )
                elif link_type == "Track":
                    Logger("Dettaching album download handler...")
                    self.client.remove_event_handler(
                        self._album_dl_handler
                    )
                elif link_type == "Playlist":
                    Logger("Dettaching playlist download handler...")
                    self.client.remove_event_handler(
                        self._playlist_dl_handler
                    )
                Logger("Failed downloading the file(s)", "WARN")
            else:
                Logger("_last_dl_status should be either Success or Failed", "WARN")
                Logger("Current value: " + self._last_dl_status, "WARN")


    def download (self, link_list):

        self.client.start()
        self.client.loop.run_until_complete(self._download(link_list))
        return self._last_dl_files

class SpotLrc():

    _url_base = "https://lrclib.net/api/search?"

    def __init__ (self, lrc_dir):
        if os.path.isdir(lrc_dir):
            self.lrc_dir = lrc_dir
            try:
                os.mkdir(lrc_dir + "/json")
            except FileExistsError:
                pass
            try:
                os.mkdir(lrc_dir + "/lyrics")
            except FileExistsError:
                pass
            try:
                os.mkdir(lrc_dir + "/plain")
            except FileExistsError:
                pass
        else:
            Logger("Directory doesn't exists.")
        pass

    def _fix_artist (self, file):

        artists = file["TPE1"].text[0]
        new_artists = ""
        write = False

        for char in artists:
            if char == "/":
                write = True
                new_artists = new_artists + ","
            else:
                new_artists = new_artists + char

        if write:
            file["TPE1"] = TPE1(text = new_artists)

        return

    def _query_lrclib (self, params):

        synced = None
        plain = None

        url = self._url_base + params
        response = requests.get(url)
        if not response.ok:
            Logger(
                "Got no lrc, response status: " + str(response.status_code)
            )
            return (None, None, None)

        Logger("Got a response...")

        if response.text == "[]":
            return (None, None, None)

        for result in json.loads(response.text):
            if synced is None:
                if result["syncedLyrics"] is not None:
                    Logger("Got a synced lyrics...")
                    synced = re.sub("\] ", "]", result["syncedLyrics"])
            if plain is None:
                if result["plainLyrics"] is not None:
                    Logger("Got a plain lyrics...")
                    plain = result["plainLyrics"]

        return (synced, plain, response)

    def _create_pe_tbl (self, track_name, artist_name, album_name, duration):

        pe_tbl = []

        ####
        param = urllib.parse.urlencode({
            "track_name": track_name,
            "artist_name": artist_name,
            "album_name": album_name,
            "duration": duration
        })

        pe_tbl.append({
            "param": param,
            "error": "Got an empty response, trying again with the track name and artist name..."
        })

        ####
        param = urllib.parse.urlencode({
            "track_name": track_name,
            "artist_name": artist_name,
        })

        pe_tbl.append({
            "param": param,
            "error": "Got an empty response, trying again with the track name and album name..."
        })

        ####
        param = urllib.parse.urlencode({
            "track_name": track_name,
            "album_name": album_name,
        })

        pe_tbl.append({
            "param": param,
            "error": "Got an empty response again, trying again with track name and the cleaned album name..."
        })

        ####
        cleaned_album_name = re.sub("\(( *)?From ?", "", album_name)
        cleaned_album_name = re.sub(" ?\)", "", cleaned_album_name)
        cleaned_album_name = re.sub("[^a-zA-Z0-9 ]", "", cleaned_album_name)

        param = urllib.parse.urlencode({
            "q": track_name + "+" + cleaned_album_name,
        })

        pe_tbl.append({
            "param": param,
            "error": "Got an empty response again, trying again with just the track name..."
        })

        ####
        param = urllib.parse.urlencode({
            "track_name": track_name
        })

        pe_tbl.append({
            "param": param,
            "error": "Still got an empty response, cleaning the title and trying once more..."
        })

        ####
        cleaned_track_name = re.sub(" ?\(.*\) ?", "", track_name)
        cleaned_track_name = re.sub("[^a-zA-Z0-9 ]", "", cleaned_track_name)

        param = urllib.parse.urlencode({
            "track_name": cleaned_track_name
        })

        pe_tbl.append({
            "param": param,
            "error": "Sorry, still got nothing..."
        })

        return pe_tbl

    def _del_uslt_tags (self, file):

        tags_to_del = []

        for key in file.keys():
            if key[0:4] == "USLT":
                tags_to_del.append(key)

        for key in tags_to_del:
            file.pop(key)

    def get_lrc (self, file_list):

        track_name = None
        artist_name = None
        album_name = None
        duration = None

        file_stem = None

        for file_path in file_list:

            file = ID3(file_path)

            file_stem = os.path.splitext(os.path.basename(file_path))[0]

            Logger(file_path)
            Logger("Querying for " + file["TIT2"].text[0] + " - " + file["TPE1"].text[0] + "...")

            Logger("Fixing artists...")
            self._fix_artist(file)
            Logger("Deleting other USLT tags...")
            self._del_uslt_tags(file)

            track_name = file["TIT2"].text[0]
            artist_name = file["TPE1"].text[0]
            album_name = file["TALB"].text[0]
            duration = str(int(int(file["TLEN"].text[0]) / 1000))

            pe_tbl = self._create_pe_tbl(
                track_name,
                artist_name,
                album_name,
                duration
            )

            synced = None
            plain = None
            response = None

            for pe in pe_tbl:
                res = self._query_lrclib(pe["param"])

                if synced is None:
                    synced = res[0]

                if plain is None:
                    plain = res[1]

                response = res[2]
                if synced is None or plain is None:
                    Logger(pe["error"])
                else:
                    break

            if response is not None:
                # TODO: give proper file names instead to slamming file_stem
                with open(self.lrc_dir + "/json/" + file_stem + ".json", "w") as tmp_file:
                    tmp_file.write(response.text)
            else:
                Logger("No response at all, weird...", "WARN")

            if synced is not None:
                file.add(USLT(text = synced, desc = "synced"))
                with open(self.lrc_dir + "/lyrics/" + file_stem + ".lrc", "w") as tmp_file:
                    tmp_file.write(synced)
                    tmp_file.write("\n")
            else:
                Logger("Haven't got the synced lyrics...")

                if plain is not None:
                    file.add(USLT(text = plain, desc = "plain"))

            if plain is not None:
                with open(self.lrc_dir + "/plain/" + file_stem + ".lrc", "w") as tmp_file:
                    tmp_file.write(plain)
                    tmp_file.write("\n")
            else:
                Logger("Haven't got the plain lyrics...")

            file.save()

def parse_config():

    global Config_Dir
    global Music_Dir
    global Lyrics_Dir
    global Api_Id
    global Api_Hash

    Config_Dir = os.path.expandvars(Config_Dir)

    config_file = Config_Dir + "/config.ini"
    if not os.path.isfile(config_file):
        print("Config file is not present: " + config_file)
        print("Inorder to sdl to work, you need the Telegram Api Id and Hash")
        print("Exiting...")
        exit()

    config = configparser.ConfigParser()
    config.read(config_file)

    Music_Dir = os.path.expandvars(config["download"]["MusicDir"])

    if not os.path.isdir(Music_Dir):
        print("Directory doesn't exists: " + Music_Dir)
        print("Please make sure you have specified the right directory to download files.")
        print("Exiting...")
        exit()

    Lyrics_Dir = os.path.expandvars(config["download"]["LyricsDir"])

    if not os.path.isdir(Lyrics_Dir):
        print("Directory doesn't exists: " + Lyrics_Dir)
        print("Please make sure you have specified the right directory to download lyrics.")
        print("Exiting...")
        exit()

    Api_Id = int(config["telegram.api"]["Id"])
    Api_Hash = config["telegram.api"]["Hash"]


def download():

    pat = re.compile("^(https://open\.spotify\.com/(.+)/.{22})(\?)?(.*)$")

    query = ""
    downloaded_list = None

    if len(sys.argv) == 2 and (sys.argv[1] == "--clip" or sys.argv[1] == "-c"):
        clip = subprocess.Popen(
            ["termux-clipboard-get"], stdout = subprocess.PIPE
        )

        clip = clip.stdout.read().decode()

        mat = pat.match(clip)

        if mat is not None:

            url_type = None

            grps = mat.groups()

            if grps[1] == "album":
                url_type = "Album"
            elif grps[1] == "track":
                url_type = "Track"
            elif grps[1] == "playlist":
                url_type = "Playlist"
            else:
                Logger("Currently only albums and tracks can be downloaded, exiting...")
                Logger("Clipboard contents: \"" + clip + "\"")
                exit()
        else:
            Logger("Clipboard does not contain a valid url, exiting...")
            Logger("Clipboard contents: \"" + clip + "\"")
            exit()

        sdl = SpotDownload(Config_Dir + "/anon", Api_Id, Api_Hash)
        downloaded_list = sdl.download([(grps[0], url_type)])
    else:
        if len(sys.argv) > 1:

            query = sys.argv[1]

            for arg in sys.argv[2:]:
                query = query + " " + arg
        else:
            print("Query: ", end = "")
            query = input()

        if query == "":
            Logger("No query, exiting...")
            exit()

        squery = SpotQuery(query)

        if squery.gen_result() is None:
            Logger("No selections were generated, exiting...")
            exit()

        sdl = SpotDownload(Config_Dir + "/anon", Api_Id, Api_Hash)
        downloaded_list = sdl.download([(squery.get_url(), squery.get_type())])

    lrc = SpotLrc(Lyrics_Dir)
    lrc.get_lrc(downloaded_list)

    return

# main()

def attach_lrc ():

    fzf = FzfPrompt()

    files = [file for file in os.listdir(Music_Dir) if file[-4:] == ".mp3"]
    files.sort(key = lambda x: os.path.getmtime(os.path.join(Music_Dir, x)))

    selected = [os.path.join(Music_Dir, file) for file in fzf.prompt(files, "--tac -m")]

    lrc = SpotLrc(Lyrics_Dir)
    lrc.get_lrc(selected)

parse_config()

if len(sys.argv) == 2 and (sys.argv[1] == "--lrc" or sys.argv[1] == "-l"):
    attach_lrc()
else:
    download()

# sdl = SpotDownload(Config_Dir + "/anon", Api_Id, Api_Hash)
# downloaded_list = sdl.download(
#     [("https://open.spotify.com/playlist/2oyDrQfkkSMdyXPXKKHm1t", "Playlist")]
# )

# https://open.spotify.com/track/2Fxmhks0bxGSBdJ92vM42m
# lrc = SpotLrc(".")
# lrc.get_lrc(["/data/data/com.termux/files/home/storage/shared/Music/sdl/Emei - Scatterbrain.mp3"])
