#!/bin/python

from telethon import TelegramClient, events, tl

from googlesearch import search
from pyfzf.pyfzf import FzfPrompt
from mutagen.id3 import ID3, USLT, TPE1

import configparser
import subprocess
import requests
import asyncio
import urllib
import json
import time
import sys
import re
import os

Config_Dir = "${HOME}/.config/sdl"

Api_Id = None
Api_Hash = None

Music_Dir = None
Lyrics_Dir = None

MIN_CHUNK_SIZE = 4096
CHUNK_COUNT = 256
REQUEST_SIZE = MIN_CHUNK_SIZE * CHUNK_COUNT

def Logger(msg, level = "LOG"):
    print(msg)

class SpotQuery:

    _re_pat = None
    _fzf = None

    def __init__ (self, query):
        if SpotQuery._re_pat is None:
            SpotQuery._re_pat = re.compile("^(https://open\.spotify\.com/(.+)/.{22})(\?)?(.*)$")
        if SpotQuery._fzf is None:
            SpotQuery._fzf = FzfPrompt()
        self.query = query
        self.query_results = None

    def _get_index (self, line):
        end = 0
        for i in range(len(line) - 1):
            if line[i] == " ":
                end = i
                break

        return int(line[0:end])

    def query_spotify_links (self, query = None):

        if query:
            self.query = query

        self.query_results = []

        for res in search("spotify " + self.query, advanced = True, num_results = 5):
            mat = self._re_pat.match(res.url)

            if mat is not None:
                groups = mat.groups()
                if groups[1] == "album" or groups[1] == "track" and groups[2] is None:
                    if groups[1] == "album":
                        res_type = "Album"
                    else:
                        res_type = "Track"

                    self.query_results.append({
                        "url": groups[0],
                        "type": res_type,
                        "title": res.title,
                        "description": res.description
                    })

        return self.query_results

    def prompt_user (self):

        if not self.query_results:
            self.query_spotify_links(self.query)

        fzf_list = []
        idx = 0

        for res in self.query_results:
            fzf_list.append(str(idx) + " " + res["type"] + ": " + res["title"])
            idx = idx + 1

        sel = self._fzf.prompt(fzf_list, "--with-nth 2..")

        if not sel:
            return None

        sel_idx = self._get_index(sel[0])

        self.selected_query_result = self.query_results[sel_idx]

        return self.selected_query_result

    def gen_result (self):

        if not self.query_results:
            self.query_spotify_links(self.query)

        return self.prompt_user()

    def get_url (self, result = None):
        if result is None:
            result = self.selected_query_result
        return result["url"]

    def get_type (self, result = None):
        if result is None:
            result = self.selected_query_result
        return result["type"]

    def get_title (self, result = None):
        if result is None:
            result = self.selected_query_result
        return result["title"]

    def get_description (self, result = None):
        if result is None:
            result = self.selected_query_result
        return result["description"]


# qry = SpotQuery("wild love jonathan")
#
# print(qry.get_title())
# print(qry.get_type())
# print(qry.get_description())
# print(qry.get_url())



# client = TelegramClient('anon', api_id, api_hash)

# The first parameter is the .session file name (absolute paths allowed)
# with TelegramClient('anon', api_id, api_hash) as client:
#     client.loop.run_until_complete(client.send_message('deezload2bot', 'Hello its mejdjdjj'))

class SpotDownload:

    client = None

    def __init__ (self, session, api_id, api_hash):
        if SpotDownload.client == None:
            SpotDownload.client = TelegramClient(session, api_id, api_hash)
        self._last_dl_status = None
        self._last_album_track_count = 0
        self._last_album_title = ""
        self._last_album_artist = ""
        self._last_album_dl_count = 0
        self._one_photo_recieved = False
        self._one_track_recieved = False
        self._download_list = None
        self._clicked_button = False
        self._last_dl_files = None

    def _set_last_album_info(self, msg_text):

        lend = 0
        lstart = 0

        while msg_text[lend] != "\n":
            lend += 1

        self._last_album_title = msg_text[9:lend]

        lend += 1
        lstart = lend

        while msg_text[lend] != "\n":
            lend += 1

        self._last_album_artist = msg_text[lstart+10:lend]

        lend += 1
        lstart = lend
        while msg_text[lend] != "\n":
            lend += 1
        lend += 1
        lstart = lend

        self._last_album_track_count = int(msg_text[lstart+16:])

    def _curate_files (self):

        if len(self._last_dl_files) < 1:
            Logger("It seems like no files have been downloaded.", "WARN")
            return

        termuxcmd = ["termux-media-scan"]

        subprocess.run(termuxcmd + self._last_dl_files)

    def _to_mb_str_bytes(self, size):
        return "%05.2f MB"%((size / 1024) / 1024)

    def _prog_callback(self, current, total):
        time_taken = time.time() - self._dl_start_time
        speed_kb = "%d KB/s" % (int((current / time_taken) / 1024))
        percent = "% 6.2f%%" % (current / total * 100)
        bars = int((current / total * 100) / 5)
        bar_str = f' {"#"*bars:<20} '

        print(percent + bar_str + speed_kb + " | " + self._to_mb_str_bytes(current) + " / " + self._to_mb_str_bytes(total), end = "\r")

    async def _download_audio (self, msg):

        file_name = ""
        for i in msg.file.name:
            if i == "\"" or i == ":" or i == "?":
                file_name = file_name + " "
            else:
                file_name = file_name + i
        file_name = Music_Dir + "/" + file_name

        self._last_dl_files.append(file_name)

        if os.path.isfile(file_name):
            Logger("File exists, skipping the download", "WARN")
            return

        tmp_file_fd = None
        download_size = 0

        tmp_file_name = Music_Dir + "/" + str(msg.document.id) + ".temp"

        if os.path.isfile(tmp_file_name):
            Logger("Temp file exists, resuming download...")
            tmp_file_fd = open(tmp_file_name, "ab")
            download_size = tmp_file_fd.tell()
            if msg.document.size == download_size:
                Logger("File is already downloaded")
            elif int(download_size / REQUEST_SIZE) * REQUEST_SIZE != download_size:
                Logger(
                    "Temp file size is not a multiple o REQUEST_SIZE\n"
                        + "Request Size: " + str(REQUEST_SIZE)
                        + ", Downloaded Size: " + str(download_size)
                )
        else:
            Logger("Starting a fresh download...")
            tmp_file_fd = open(tmp_file_name, "wb")

        print("File: " + file_name + " | Size: " + self._to_mb_str_bytes(msg.document.size))

        self._dl_start_time = time.time()
        async for chunk in self.client.iter_download(
            msg.document, offset = download_size, request_size = REQUEST_SIZE):
            download_size += len(chunk)
            tmp_file_fd.write(chunk)
            self._prog_callback(download_size, msg.document.size)
        print("")

        tmp_file_fd.close()

        if download_size == msg.document.size:
            os.rename(tmp_file_name, file_name)
        else:
            Logger("Size of the downloaded file doesn't match with the size from Telegram,\nprobably corrupted", "WARN")

        # print("name: ", msg.file.name)
        # print("ext: ", msg.file.ext)
        # print("mime_type: ", msg.file.mime_type)
        # print("width: ", msg.file.width)
        # print("height: ", msg.file.height)
        # print("size: ", msg.file.size)
        # print("duration: ", msg.file.duration)
        # print("title: ", msg.file.title)
        # print("performer: ", msg.file.performer)

    async def _download_audio_files (self):

        print("")
        for msg in self._download_list:
            await self._download_audio(msg)
        print("")

        await self.client.disconnect()

    async def _album_dl_handler (self, event):
        await event.mark_read()
        if event.message.message == "Invalid link ;)":
            Logger("Link was Invalid. Disconnecting...")
            self._last_dl_status = "Failed"
            await self.client.disconnect()

        if event.audio:
            if not self._clicked_button:
                Logger("Directly recieving the tracks")
                self._clicked_button = True

            self._download_list.append(event)
            # await self._download_audio(event)
            self._last_album_dl_count += 1
            if self._last_album_track_count == self._last_album_dl_count and self._one_photo_recieved:
                Logger("Downloaded all the tracks. Disconnecting...")
                self._last_dl_status = "Success"
                Logger("Dettaching album download handler...")
                self.client.remove_event_handler(
                    self._album_dl_handler
                )
                await self._download_audio_files()
            return
        elif event.message.message == "Downloading…":
            Logger("Recived one message with a Downloading…")
            return
        elif event.buttons:

            if self._clicked_button:
                Logger("Got another message with buttons", "WARN")
                return

            # This must be the first msg if the url is a proper one
            self._set_last_album_info(event.message.message)
            Logger("Album Track Count: " + str(self._last_album_track_count))
            Logger("Message has buttons")
            for row in event.buttons:
                for btn in row:
                    if btn.text == "GET ALL ⬇️":
                        Logger("Clicking GET ALL button")
                        self._clicked_button = True
                        await btn.click()
            if not self._clicked_button:
                Logger("Seems like there were no GET ALL button")
                if self._last_album_track_count == 1:
                    Logger("Clicking the first button")
                    self._one_photo_recieved = True
                    self._clicked_button = True
                    await event.buttons[0][0].click()
                else:
                    Logger("Track Count is not 1, somethings wrong", "WARN")

        elif event.photo:
            if not self._clicked_button:
                Logger("Seems like we are recieving tracks directly")
                self._set_last_album_info(event.message.message)
                Logger("Album Track Count: " + str(self._last_album_track_count))
                self._clicked_button = True

            self._one_photo_recieved = True
            Logger("Recived one message with a photo")
            return

    async def _track_dl_handler (self, event):
        await event.mark_read()
        if event.message.message == "Track not found." or event.message.message == "Invalid link ;)":
            if event.message.message == "Track not found.":
                Logger("Track no found. Disconnecting...", "WARN")
            else:
                Logger("Link was Invalid. Disconnecting...", "WARN")
            self._last_dl_status = "Failed"
            await self.client.disconnect()

        if event.audio:
            Logger("Recived one message with an audio")
            self._one_track_recieved = True
            self._download_list.append(event)
            # await self._download_audio(event)

        if event.photo:
            Logger("Recived one message with a photo")
            self._one_photo_recieved = True

        if self._one_photo_recieved and self._one_track_recieved:
            Logger("Recieved the track and the photo. Disconnecting...")
            self._last_dl_status = "Success"
            Logger("Dettaching track download handler...")
            self.client.remove_event_handler(
                self._track_dl_handler
            )
            await self._download_audio_files()


    async def _download (self, link_list):

        for link in link_list:
            # TODO: playlist
            link_url = link[0]  # should be a spotify url to a track or an album
            link_type = link[1] # should be Track or Album

            if not self.client.is_connected():
                Logger("Connecting to Telegram...")
                await self.client.connect()
                Logger("Connected to Telegram")

            Logger("Sending the url to deezload2bot")
            await self.client.send_message(
                "deezload2bot", link_url
            )
            if link_type == "Album":
                Logger("Attaching album download handler...")
                self.client.add_event_handler(
                    self._album_dl_handler,
                    events.NewMessage(chats = [ 'deezload2bot' ], incoming = True)
                )
                self._last_album_track_count = 0
                self._last_album_title = ""
                self._last_album_artist = ""
                self._last_album_dl_count = 0
                self._clicked_button = False
            else:
                Logger("Attaching track download handler...")
                self.client.add_event_handler(
                    self._track_dl_handler,
                    events.NewMessage(chats = [ 'deezload2bot' ], incoming = True)
                )
                self._one_track_recieved = False

            self._last_dl_status = None
            self._last_dl_files = []
            self._one_photo_recieved = False
            self._download_list = []

            Logger("Waiting for the reply from deezload2bot...")
            await self.client.run_until_disconnected()

            if self._last_dl_status == "Success":
                Logger("Succeded downloading the file(s)")
                self._curate_files()
            elif self._last_dl_status == "Failed":
                if link_type == "Album":
                    Logger("Dettaching track download handler...")
                    self.client.remove_event_handler(
                        self._track_dl_handler
                    )
                else:
                    Logger("Dettaching album download handler...")
                    self.client.remove_event_handler(
                        self._album_dl_handler
                    )
                Logger("Failed downloading the file(s)", "WARN")
            else:
                Logger("_last_dl_status should be either Success or Failed", "WARN")
                Logger("Current value: " + self._last_dl_status, "WARN")


    def download (self, link_list):

        self.client.start()
        self.client.loop.run_until_complete(self._download(link_list))
        return self._last_dl_files

class SpotLrc():

    _url_base = "https://lrclib.net/api/search?"

    def __init__ (self, lrc_dir):
        if os.path.isdir(lrc_dir):
            self.lrc_dir = lrc_dir
            try:
                os.mkdir(lrc_dir + "/json")
            except FileExistsError:
                pass
            try:
                os.mkdir(lrc_dir + "/lyrics")
            except FileExistsError:
                pass
            try:
                os.mkdir(lrc_dir + "/plain")
            except FileExistsError:
                pass
        else:
            Logger("Directory doesn't exists.")
        pass

    def _fix_artist (self, file):

        artists = file["TPE1"].text[0]
        new_artists = ""
        write = False

        for char in artists:
            if char == "/":
                write = True
                new_artists = new_artists + ","
            else:
                new_artists = new_artists + char

        if write:
            file["TPE1"] = TPE1(text = new_artists)

        return

    def get_lrc (self, file_list):

        track_name = None
        artist_name = None
        album_name = None
        duration = None

        params = None
        url = None

        file_stem = None

        for file_path in file_list:

            file = ID3(file_path)

            file_stem = os.path.splitext(os.path.basename(file_path))[0]

            self._fix_artist(file)
            track_name = file["TIT2"].text[0]
            artist_name = file["TPE1"].text[0]
            album_name = file["TALB"].text[0]
            duration = str(int(int(file["TLEN"].text[0]) / 1000))

            params = urllib.parse.urlencode({
                "track_name": track_name,
                "artist_name": artist_name,
                "album_name": album_name,
                "duration": duration,
            })

            url = self._url_base + params

            response = requests.get(url)
            synced = None
            plain = None

            if response.ok:

                with open(self.lrc_dir + "/json/" + file_stem + ".json", "w") as tmp_file:
                    tmp_file.write(response.text)

                Logger("Got response...")

                for result in json.loads(response.text):
                    if synced is None:
                        Logger("Got synced lyrics...")
                        if result["syncedLyrics"] is not None:
                            synced = re.sub("\] ", "]", result["syncedLyrics"])
                    if plain is None:
                        Logger("Got plain lyrics...")
                        if result["plainLyrics"] is not None:
                            plain = result["plainLyrics"]

                if synced is not None:
                    file.add(USLT(text = synced, desc = "synced"))
                    with open(self.lrc_dir + "/lyrics/" + file_stem + ".lrc", "w") as tmp_file:
                        tmp_file.write(synced)
                        tmp_file.write("\n")
                else:
                    if plain is not None:
                        file.add(USLT(text = plain, desc = "plain"))
                    Logger("Haven't got the synced lyrics")


                if plain is not None:
                    with open(self.lrc_dir + "/lyrics/" + file_stem + ".lrc", "w") as tmp_file:
                        tmp_file.write(plain)
                        tmp_file.write("\n")
                else:
                    Logger("Haven't got the plain lyrics")

            else:
                Logger(
                    "Got no lrc, response status: " + str(response.status_code)
                )

            file.save()

def main():

    global Config_Dir
    global Music_Dir
    global Lyrics_Dir
    global Api_Id
    global Api_Hash

    Config_Dir = os.path.expandvars(Config_Dir)

    config_file = Config_Dir + "/config.ini"
    if not os.path.isfile(config_file):
        print("Config file is not present: " + config_file)
        print("Inorder to sdl to work, you need the Telegram Api Id and Hash")
        print("Exiting...")
        exit()

    config = configparser.ConfigParser()
    config.read(config_file)

    Music_Dir = os.path.expandvars(config["download"]["MusicDir"])

    if not os.path.isdir(Music_Dir):
        print("Directory doesn't exists: " + Music_Dir)
        print("Please make sure you have specified the right directory to download files.")
        print("Exiting...")
        exit()

    Lyrics_Dir = os.path.expandvars(config["download"]["LyricsDir"])

    if not os.path.isdir(Lyrics_Dir):
        print("Directory doesn't exists: " + Lyrics_Dir)
        print("Please make sure you have specified the right directory to download lyrics.")
        print("Exiting...")
        exit()

    Api_Id = int(config["telegram.api"]["Id"])
    Api_Hash = config["telegram.api"]["Hash"]

    # TODO: download directly from links
    # pat = re.compile("^(https://open\.spotify\.com/(.+)/.{22})(\?)?(.*)$")

    query = ""

    if len(sys.argv) > 1:

        query = sys.argv[1]

        for arg in sys.argv[2:]:
            query = query + " " + arg
    else:
        print("Query: ", end = "")
        query = input()

    if query == "":
        Logger("No query, exiting...")
        exit()

    squery = SpotQuery(query)

    if squery.gen_result() is None:
        Logger("No selections were generated, exiting...")
        exit()

    sdl = SpotDownload(Config_Dir + "/anon", Api_Id, Api_Hash)
    downloaded_list = sdl.download([(squery.get_url(), squery.get_type())])

    lrc = SpotLrc(Lyrics_Dir)
    lrc.get_lrc(downloaded_list)

    return

# main()
lrc = SpotLrc(".")
lrc.get_lrc(["in.mp3"])
