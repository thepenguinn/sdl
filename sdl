#!/bin/python

from telethon import TelegramClient, events, tl

from pyfzf.pyfzf import FzfPrompt
from mutagen.id3 import ID3, USLT, TPE1
from threading import Thread, Lock
from bs4 import BeautifulSoup
from pprint import pprint
from enum import Enum

import configparser
import subprocess
import requests
import asyncio
import urllib
import socket
import json
import time
import sys
import re
import os

Config_Dir = "${HOME}/.config/sdl"

Api_Id = None
Api_Hash = None

Music_Dir = None
Lyrics_Dir = None

MIN_CHUNK_SIZE = 4096
CHUNK_COUNT = 256
REQUEST_SIZE = MIN_CHUNK_SIZE * CHUNK_COUNT

def Logger(msg, level = "LOG"):
    print(msg)

class SpotQuery:

    _re_pat = None
    _fzf = None
    _headers = {"user-agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) QtWebEngine/5.15.3 Chrome/87.0.4280.144 Safari/537.36"}


    def __init__ (self, query):

        if SpotQuery._re_pat is None:
            SpotQuery._re_pat = re.compile("^(https://open\.spotify\.com/(.+)/.{22})(\?)?(.*)$")
        if SpotQuery._fzf is None:
            SpotQuery._fzf = FzfPrompt()
        self.query = query
        self.query_results = None

        return

    def _get_index (self, line):
        end = 0
        for i in range(len(line) - 1):
            if line[i] == " ":
                end = i
                break

        return int(line[0:end])

    def _create_url (self, query):

        new = ""
        for i in query:
            if i == " ":
                new = new + "+"
            else:
                new = new + i
        query = new

        return "https://www.google.com/search?q=" + query + "+spotify&ei=JVlSYtHCA-6MseMPwNGeiAc&ved=0ahUKEwiR6fbF0Ij3AhVuRmwGHcCoB3EQ4dUDCA4&uact=5&oq=" + query + "+spotify&gs_lcp=Cgdnd3Mtd2l6EANKBAhBGABKBAhGGABQAFi1c2C5dmgEcAF4AIAByQGIAfkikgEGMC4zMC4xmAEAoAEBwAEB&sclient=gws-wiz"

    def _refine_link (self, link):

        # only works if we don't pass the headers
        res = requests.get(link["url"])

        if not res.ok:
            Logger("Spotify query failed", "WARN")
            return link

        soup = BeautifulSoup(res.text, "html.parser")

        for meta in soup.find_all("meta"):
            if meta.has_attr("name") and meta["name"] == "twitter:title":
                if meta.has_attr("content") and meta["content"] != "":
                    link["title"] = meta["content"]
                    return link


    def query_from_google (self, query):

        Logger("query_from_google")

        if query is None:
            None

        query_results = []

        url = self._create_url(query)

        res = requests.get(url, headers = self._headers)

        if not res.ok:
            Logger("Google query failed", "WARN")
            return None

        with open("google.html", "w") as f:
            f.write(res.text)

        soup = BeautifulSoup(res.text, "html.parser")

        for h3 in soup.find_all("h3"):
            if h3.parent.has_attr("href"):
                title = h3.text
                mat = self._re_pat.match(h3.parent["href"])

                if mat is None:
                    continue

                groups = mat.groups()

                if groups[1] == "album":
                    res_type = "album"
                elif groups[1] == "track":
                    res_type = "track"
                else:
                    continue

                query_results.append(
                    self._refine_link({
                        "url": groups[0],
                        "type": res_type,
                        "title": title
                    })
                )

        if len(query_results) > 0:
            return query_results
        else:
            return None

    def query_by_album_from_spotify (self, album_url):

        # queries the songs of the album, but not sure whether
        # this will return all of the tracks if the album has a
        # track count larger the 30 songs. This will be usefull
        # to get the albums having a single track.

        query_results = []

        # only works if we don't pass the headers
        res = requests.get(album_url)

        if not res.ok:
            Logger("Spotify query failed", "WARN")
            return None

        soup = BeautifulSoup(res.text, "html.parser")

        for div in soup.find_all("div"):
            if div.has_attr("aria-label"):
                # TODO: make sure this url is actually a track url
                query_results.append({
                    "title": div["aria-label"],
                    "url": re.sub(
                        "^.*track:", "https://open.spotify.com/track/", div["aria-labelledby"]
                    ),
                    "type": "track"
                })

        if len(query_results) > 0:
            return query_results
        else:
            Logger("Got no tracks", "WARN")
            return None

    def _is_in (self, val, lis, key):

        idx = -1

        for i in range(len(lis)):
            if lis[i][key] == val:
                idx = i
                break

        return idx


    def query_by_track_from_spotify (self, track_url, google_results):

        # queries the track from spotify, this hopefully returns
        # the album and the related tracks.

        query_results = []

        # only works if we don't pass the headers
        res = requests.get(track_url)

        if not res.ok:
            Logger("Spotify query failed", "WARN")
            return None

        soup = BeautifulSoup(res.text, "html.parser")

        for div in soup.find_all("div"):
            if div.text[0:6] == "Single":
                parent = div.find_parent()
                if parent.has_attr("href"):
                    Logger("Got a Song")

                    title = None
                    for child in parent.children:
                        if child.has_attr("dir"):
                            title = child.text
                            break
                    if title is None:
                        Logger("Haven't got a title", "WARN")

                    url = "https://open.spotify.com" + parent["href"]
                    url_type = None

                    if parent["href"][0:6] == "/album":
                        Logger("The song has an album url, querying for the track url")
                        url_list = self.query_by_album_from_spotify(url)

                        if url_list is None:
                            Logger("query_by_album_from_spotify() returned nothing", "WARN")

                        idx = self._is_in(url_list[0]["url"], google_results, "url")

                        if idx > -1:
                            Logger("This url is in the google results")
                            if len(google_results[idx]["title"]) < len(url_list[0]["title"]):
                                Logger("New title is bigger than old, so updating")
                                Logger("Old: " + google_results[idx]["title"])
                                Logger("New: " + url_list[0]["title"])
                                google_results[idx]["title"] = url_list[0]["title"]
                            continue

                        if len(url_list) == 1:
                            if url_list[0]["type"] == "track":
                                Logger("Got the track url")
                                url = url_list[0]["url"]
                                url_type = "track"
                            else:
                                Logger("Haven't got a track url, instead got a " + url_list[0]["url"], "WARN")
                        elif len(url_list) > 1:
                            Logger("query_by_album_from_spotify() returned more than one links, merging it with the results")
                            query_results = query_results + url_list
                            continue

                    elif parent["href"][0:6] == "/track":
                        Logger("The song has an track url")
                        url_type = "track"
                    else:
                        Logger("The song neither has a track url or an album url", "WARN")

                    if url is not None and url_type is not None and title is not None:
                        query_results.append({
                            "title": title,
                            "url": url,
                            "type": url_type
                        })
                        print("")
                    else:
                        Logger("One of url, url_type, and title was None", "WARN")


            elif div.text[0:5] == "Album":

                parent = div.find_parent()

                if parent.has_attr("href"):
                    Logger("Got an Ablum")

                    title = None
                    for child in parent.children:
                        if child.has_attr("dir"):
                            title = child.text
                            break
                    if title is None:
                        Logger("Haven't got a title", "WARN")

                    if parent["href"][0:6] == "/album":
                        url_type = "album"
                    else:
                        Logger("url is not a album url", "WARN")
                        url_type = None

                    url = "https://open.spotify.com" + parent["href"]

                    if url is not None and url_type is not None and title is not None:
                        query_results.append({
                            "title": title,
                            "url": url,
                            "type": url_type
                        })
                        print("")
                    else:
                        Logger("One of url, url_type, and title was None", "WARN")

        if len(query_results) > 0:
            return query_results
        else:
            Logger("Got no links", "WARN")
            return None


    def query_from_spotify (self, url, url_type, google_results):

        if url_type == "track":
            return self.query_by_track_from_spotify(url, google_results)
        elif url_type == "ablum":
            return self.query_by_album_from_spotify(url)
        else:
            Logger("Currently only tracks and albums can be queried from spotify", "WARN")
            return None

    def query_links (self, query):

        if query is None:
            return None

        gres = self.query_from_google(query)

        if gres is None:
            return None

        sres = None

        for link in gres:
            if link["type"] == "track":
                print(link["url"])
                sres = self.query_from_spotify(link["url"], link["type"], gres)
                break

        if sres is not None:
            gres = gres + sres

        return gres

    def prompt_user (self, query_list):

        fzf_list = []
        idx = 0


        for res in query_list:
            if res["type"] == "album":
                url_type = "Album"
            elif res["type"] == "track":
                url_type = "Track"
            elif res["type"] == "playlist":
                url_type = "Playlist"
            else:
                url_type = "Umm"
            fzf_list.append(str(idx) + " " + url_type + ": " + res["title"])
            idx = idx + 1

        sel = self._fzf.prompt(fzf_list, "--with-nth 2..")

        if not sel:
            return None

        sel_idx = self._get_index(sel[0])

        return query_list[sel_idx]


    def gen_result (self):

        if self.query_results is None:
            self.query_results = self.query_links(self.query)
            if self.query_results is None:
                Logger("No query results were generated from google", "WARN")
                return None

        self.selected_query_result = self.prompt_user(self.query_results)

        return self.selected_query_result

    def get_url (self, result = None):
        if result is None:
            result = self.selected_query_result
        return result["url"]

    def get_type (self, result = None):
        if result is None:
            result = self.selected_query_result
        return result["type"]

    def get_title (self, result = None):
        if result is None:
            result = self.selected_query_result
        return result["title"]

class SpotDaemon:

    client = None

    # TESTING
    Status = Enum(
        "Status", [
            "LOG",
            "WARN",
            "SEND",
            "PROGRESS",
            "FAILED",
            "SUCCESS",
        ]
    )

    Command = Enum(
        "Command", [
            "ADD",
            "STOP",
        ]
    )

    def __init__ (self, session, api_id, api_hash, port, backlog = 5):

        self._session = session
        self._api_id = api_id
        self._api_hash = api_hash
        self._port = port
        self._backlog = backlog

        return

    def _init (self):

        # TESTING #
        ### if self.client == None:
        ###     self.client = TelegramClient(
        ###         self._session, self._api_id, self._api_hash
        ###     )

        # Everything that related with downloading files
        self._last_download_status = None
        self._last_album_track_count = 0
        self._last_album_title = ""
        self._last_album_artist = ""
        self._last_album_download_count = 0
        self._one_photo_recieved = False
        self._one_track_recieved = False
        self._download_list = None
        self._clicked_button = False
        self._last_download_files = None
        self._last_playlist_download_count = 0

        # Status Logger
        self._status_logger_file_fd = open("status.log", "w")
        self._status_conn_broke = False
        self._status_pending = []

        # Everything that relate to daemon
        self._is_connected = False
        self._daemon_logger_file_path = "daemon.log"
        self._daemon_logger_file_fd = None
        return

    def _set_last_album_info (self, msg_text):

        lend = 0
        lstart = 0

        while msg_text[lend] != "\n":
            lend += 1

        self._last_album_title = msg_text[9:lend]

        lend += 1
        lstart = lend

        while msg_text[lend] != "\n":
            lend += 1

        self._last_album_artist = msg_text[lstart+10:lend]

        lend += 1
        lstart = lend
        while msg_text[lend] != "\n":
            lend += 1
        lend += 1
        lstart = lend

        self._last_album_track_count = int(msg_text[lstart+16:])

    def _curate_files (self):

        if len(self._last_download_files) < 1:
            Logger("It seems like no files have been downloaded.", "WARN")
            return

        termuxcmd = ["termux-media-scan"]

        subprocess.run(termuxcmd + self._last_download_files)

    def _to_mb_str_bytes(self, size):
        return "%05.2f MB"%((size / 1024) / 1024)

    def _prog_callback(self, current, total):
        time_taken = time.time() - self._download_start_time
        speed_kb = "%d KB/s" % (int((current / time_taken) / 1024))
        percent = "% 6.2f%%" % (current / total * 100)
        bars = int((current / total * 100) / 5)
        bar_str = f' {"#"*bars:<20} '

        print(percent + bar_str + speed_kb + " | " + self._to_mb_str_bytes(current) + " / " + self._to_mb_str_bytes(total), end = "\r")

    def _status_logger (self, message, level = None):

        if level is None:
            level = self.Status.LOG

        cur_time = time.monotonic()

        # if level == Status.LOG:
        # elif level == self.Status.WARN:
        # elif level == Status.SEND:
        # elif level == Status.PROGRESS:
        # elif level == Status.FAILED:
        # elif level == Status.SUCCESS:
        # else:

        status = {
            "level": level.value,
            "time": cur_time,
            "message": message
        }

        payload = json.dumps(status).encode()

        size = len(payload)

        header = bytearray([
            size & 0xff, (size >> 8) & 0xff, (size >> 16) & 0xff, (size >> 24) & 0xff
        ])

        try:
            self._status_lock.acquire()
            self._status_socket.send(header + payload)
        except Exception as e:
            # self._status_logger_file_fd.write(e.args[0])
            # self._status_logger_file_fd.flush()
            self._data_lock.acquire()
            self._status_pending.append(status)
        finally:
            if self._status_lock.locked():
                self._status_lock.release()
            if self._data_lock.locked():
                self._data_lock.release()

        self._status_logger_file_fd.write(
            level.name + ": " + str(cur_time) + ": " + str(message) + "\n"
        )
        self._status_logger_file_fd.flush()

    async def _download_audio (self, msg):

        file_name = ""
        for i in msg.file.name:
            if i == "\"" or i == ":" or i == "?":
                file_name = file_name + " "
            else:
                file_name = file_name + i
        file_name = Music_Dir + "/" + file_name

        if os.path.isfile(file_name):
            self._status_logger("File exists, skipping the download", self.Status.WARN)
            return

        self._last_download_files.append(file_name)

        tmp_file_fd = None
        download_size = 0

        tmp_file_name = Music_Dir + "/" + str(msg.document.id) + ".temp"

        if os.path.isfile(tmp_file_name):
            self._status_logger("Temp file exists, resuming download...")
            tmp_file_fd = open(tmp_file_name, "ab")
            download_size = tmp_file_fd.tell()
            if msg.document.size == download_size:
                self._status_logger("File is already downloaded")
            elif int(download_size / REQUEST_SIZE) * REQUEST_SIZE != download_size:
                self._status_logger(
                    "Temp file size is not a multiple o REQUEST_SIZE\n"
                        + "Request Size: " + str(REQUEST_SIZE)
                        + ", Downloaded Size: " + str(download_size)
                )
        else:
            self._status_logger("Starting a fresh download...")
            tmp_file_fd = open(tmp_file_name, "wb")

        print("File: " + file_name + " | Size: " + self._to_mb_str_bytes(msg.document.size))

        self._download_start_time = time.time()
        async for chunk in self.client.iter_download(
            msg.document, offset = download_size, request_size = REQUEST_SIZE):
            download_size += len(chunk)
            tmp_file_fd.write(chunk)
            self._prog_callback(download_size, msg.document.size)
        print("")

        tmp_file_fd.close()

        if download_size == msg.document.size:
            os.rename(tmp_file_name, file_name)
        else:
            self._status_logger("Size of the downloaded file doesn't match with the size from Telegram,\nprobably corrupted", self.Status.WARN)

    async def _download_audio_files (self):

        print("")
        for msg in self._download_list:
            await self._download_audio(msg)
        print("")

        await self.client.disconnect()

    async def _album_download_handler (self, event):
        await event.mark_read()
        if event.message.message == "Invalid link ;)":
            self._status_logger("Link was Invalid. Disconnecting...")
            self._last_download_status = "Failed"
            await self.client.disconnect()

        if event.audio:
            if not self._clicked_button:
                self._status_logger("Directly recieving the tracks")
                self._clicked_button = True

            self._download_list.append(event)
            # await self._download_audio(event)
            self._last_album_download_count += 1
            if self._last_album_track_count == self._last_album_download_count and self._one_photo_recieved:
                self._status_logger("Downloaded all the tracks. Disconnecting...")
                self._last_download_status = "Success"
                self._status_logger("Dettaching album download handler...")
                self.client.remove_event_handler(
                    self._album_download_handler
                )
                await self._download_audio_files()
            return
        elif event.message.message == "Downloading…":
            self._status_logger("Recived one message with a Downloading…")
            return
        elif event.buttons:

            if self._clicked_button:
                self._status_logger("Got another message with buttons", self.Status.WARN)
                return

            # This must be the first msg if the url is a proper one
            self._set_last_album_info(event.message.message)
            self._status_logger("Album Track Count: " + str(self._last_album_track_count))
            self._status_logger("Message has buttons")
            for row in event.buttons:
                for btn in row:
                    if btn.text == "GET ALL ⬇️":
                        self._status_logger("Clicking GET ALL button")
                        self._clicked_button = True
                        await btn.click()
            if not self._clicked_button:
                self._status_logger("Seems like there were no GET ALL button")
                if self._last_album_track_count == 1:
                    self._status_logger("Clicking the first button")
                    self._one_photo_recieved = True
                    self._clicked_button = True
                    await event.buttons[0][0].click()
                else:
                    self._status_logger("Track Count is not 1, somethings wrong", self.Status.WARN)

        elif event.photo:
            if not self._clicked_button:
                self._status_logger("Seems like we are recieving tracks directly")
                self._set_last_album_info(event.message.message)
                self._status_logger("Album Track Count: " + str(self._last_album_track_count))
                self._clicked_button = True

            self._one_photo_recieved = True
            self._status_logger("Recived one message with a photo")
            return

    async def _track_download_handler (self, event):
        await event.mark_read()
        if event.message.message == "Track not found." or event.message.message == "Invalid link ;)":
            if event.message.message == "Track not found.":
                self._status_logger("Track no found. Disconnecting...", self.Status.WARN)
            else:
                self._status_logger("Link was Invalid. Disconnecting...", self.Status.WARN)
            self._last_download_status = "Failed"
            await self.client.disconnect()

        if event.audio:
            self._status_logger("Recived one message with an audio")
            self._one_track_recieved = True
            self._download_list.append(event)
            # await self._download_audio(event)

        if event.photo:
            self._status_logger("Recived one message with a photo")
            self._one_photo_recieved = True

        if self._one_photo_recieved and self._one_track_recieved:
            self._status_logger("Recieved the track and the photo. Disconnecting...")
            self._last_download_status = "Success"
            self._status_logger("Dettaching track download handler...")
            self.client.remove_event_handler(
                self._track_download_handler
            )
            await self._download_audio_files()

    async def _playlist_download_handler (self, event):
        await event.mark_read()
        if event.message.message == "Invalid link ;)":
            self._status_logger("Link was Invalid. Disconnecting...")
            self._last_download_status = "Failed"
            await self.client.disconnect()

        if event.buttons:
            if self._clicked_button:
                self._status_logger("Got another message with buttons.", self.Status.WARN)
                if event.message.message == "Downloading…":
                    self._status_logger("Its the Downloading message")
                else:
                    self._status_logger("Its not the Downloading message", self.Status.WARN)
                return

            if event.buttons[0][0].text == "GET ALL ⬇️":
                self._status_logger("Clicking GET ALL button")
                self._clicked_button = True
                await event.buttons[0][0].click()
        elif event.audio:
            self._download_list.append(event)
            self._last_playlist_download_count += 1
        elif event.message.message == "Finished.":
            self._status_logger("Downloaded all the tracks. Disconnecting...")
            self._last_download_status = "Success"
            self._status_logger("Dettaching playlist download handler...")
            self.client.remove_event_handler(
                self._playlist_download_handler
            )
            # print(self._last_playlist_download_count)
            await self._download_audio_files()
        else:
            self._status_logger("Recieved some other message", self.Status.WARN)
            print(event.message.message)

    async def _download (self, link_list):

        for link in link_list:
            # TODO: playlist
            link_url = link[0]  # should be a spotify url to a track or an album
            link_type = link[1] # should be Track or Album

            if not self.client.is_connected():
                self._status_logger("Connecting to Telegram...")
                await self.client.connect()
                self._status_logger("Connected to Telegram")

            self._status_logger("Sending the url to deezload2bot")
            await self.client.send_message(
                "deezload2bot", link_url
            )
            if link_type == "album":
                self._status_logger("Attaching album download handler...")
                self.client.add_event_handler(
                    self._album_download_handler,
                    events.NewMessage(chats = [ 'deezload2bot' ], incoming = True)
                )
                self._last_album_track_count = 0
                self._last_album_title = ""
                self._last_album_artist = ""
                self._last_album_download_count = 0
                self._clicked_button = False
            elif link_type == "track":
                self._status_logger("Attaching track download handler...")
                self.client.add_event_handler(
                    self._track_download_handler,
                    events.NewMessage(chats = [ 'deezload2bot' ], incoming = True)
                )
                self._one_track_recieved = False
            elif link_type == "playlist":
                self._status_logger("Attaching playlist download handler...")
                self.client.add_event_handler(
                    self._playlist_download_handler,
                    events.NewMessage(chats = [ 'deezload2bot' ], incoming = True)
                )
                self._clicked_button = False
                self._last_playlist_download_count = 0


            self._last_download_status = None
            self._last_download_files = []
            self._one_photo_recieved = False
            self._download_list = []

            self._status_logger("Waiting for the reply from deezload2bot...")
            await self.client.run_until_disconnected()

            if self._last_download_status == "Success":
                self._status_logger("Succeded downloading the file(s)")
                self._curate_files()
            elif self._last_download_status == "Failed":
                if link_type == "album":
                    self._status_logger("Dettaching track download handler...")
                    self.client.remove_event_handler(
                        self._track_download_handler
                    )
                elif link_type == "track":
                    self._status_logger("Dettaching album download handler...")
                    self.client.remove_event_handler(
                        self._album_download_handler
                    )
                elif link_type == "playlist":
                    self._status_logger("Dettaching playlist download handler...")
                    self.client.remove_event_handler(
                        self._playlist_download_handler
                    )
                self._status_logger("Failed downloading the file(s)", self.Status.WARN)
            else:
                self._status_logger("_last_download_status should be either Success or Failed", self.Status.WARN)
                self._status_logger("Current value: " + self._last_download_status, self.Status.WARN)


    def download (self, link_list):

        self.client.start()
        self.client.loop.run_until_complete(self._download(link_list))
        return self._last_download_files

    def _daemon_logger (self, msg, level = "LOG"):
        self._daemon_logger_file_fd.write(msg + "\n")
        self._daemon_logger_file_fd.flush()
        return

    def _download_thread_handler (self):

        time.sleep(1)
        self._status_logger("lol")
        time.sleep(1)
        self._status_logger("hai again")
        time.sleep(2)
        self._status_logger("hai again after another 2 seconds")
        time.sleep(3)
        self._status_logger("That was too long, almost 3 seconds")

        self._status_logger("Now exiting")

        return

    def _cal_payload_size (self, four_bytes):

        return four_bytes[0] | four_bytes[1] << 8 | four_bytes[2] << 16 | four_bytes[3] << 24

    def _command_thread_handlier (self, command_socket):

        while True:
            # TESTING: this should block here till daemon got disconnected
            size = command_socket.recv(4)
            if size == b'':
                self._daemon_logger("It seems like the client got disconnected", "WARN")
                break

            size = self._cal_payload_size(size)
            self._daemon_logger( "size of the payload: " + str(size), "WARN")
            payload = command_socket.recv(size)
            if payload == b'':
                self._daemon_logger(
                    "It seems like the client got disconnected, before sending the payload",
                    "WARN"
                )
                break

            command = json.loads(payload.decode())

        self._daemon_logger("Leaving the _command_thread_handlier loop", "WARN")

        return

    def _daemon_server_init(self, port, backlog):
        # TODO: handle exceptions
        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server.bind((socket.gethostname(), port))
        server.listen(backlog)

        return server

    def run (self):

        self._init()

        self._stop_daemon = False

        if self._daemon_logger_file_fd is None:
            self._daemon_logger_file_fd = open(self._daemon_logger_file_path, "w")
            self._daemon_logger_file_fd.write("Aloha!\n")

        self._daemon_logger("Started the server")
        server = self._daemon_server_init(self._port, self._backlog)
        self._daemon_logger("Succesfully initialized the server")

        self._status_lock = Lock()
        self._data_lock = Lock()

        download_thread = None

        while True:

            # OK connection
            self._daemon_logger("Now accepting for OK msg")
            client, addr = server.accept()

            self._daemon_logger("Client connected, sending 'OK'")
            client.send("OK".encode())

            self._daemon_logger("Now waiting for the client to disconnect...")
            # client should disconnect this connection
            msg = client.recv(1)
            if msg != b'':
                self._daemon_logger("Client keep sending something", "WARN")
            else:
                self._daemon_logger("Client got disconnected")

            # Actual connection
            self._daemon_logger("Initiating for the actual connection")
            self._daemon_logger("Waiting for the client to connect for the status connection")
            # this socket will be used to send the status, the client should
            # only be recving from this socket, DO NOT SEND anything.

            self._status_lock.acquire()
            self._status_socket, addr = server.accept()
            self._status_lock.release()
            self._daemon_logger("Client got connected")

            # we might not need a seperate thread for status.
            # we could just handle it from the download thread.
            # status_thread = Thread(target = self._status_thread_handler, args = [client])

            self._daemon_logger("Waiting for the client to connect for the command connection")
            # client can read and write from this connection
            # the daemon will respond to each of the commands through
            # this socket
            command_socket, addr = server.accept()
            self._daemon_logger("Client got connected")

            # status_socket should be a shared resource
            if download_thread is None:
                # this thread should never raise any exceptions that
                # means this thread should only stop when the daemon
                # is exiting
                download_thread = Thread(target = self._download_thread_handler)

                self._daemon_logger("Starting the download thread")
                download_thread.start()

            # main thread will handle the command connection
            self._daemon_logger("Starting the command thread")
            self._command_thread_handlier(command_socket)

            if self._stop_daemon:
                break

            if not download_thread.is_alive():
                self._daemon_logger("download_thread is not alive, probably crashed", "WARN")
                break

        self._daemon_logger("Exiting...", "WARN")

        return

class SpotClient:

    daemon = None

    def __init__ (self, session, api_id, api_hash, port = 49524):

        if self.daemon is None:
            self.daemon = SpotDaemon(session, api_id, api_hash, port)
        self._api_id = api_id
        self._api_hash = api_hash
        self._port = port
        self._is_connected = False

        return

    def _cal_payload_size (self, four_bytes):

        return four_bytes[0] | four_bytes[1] << 8 | four_bytes[2] << 16 | four_bytes[3] << 24

    def _est_daemon_connection (self):
        # this will block
        try:
            connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            connection.connect((socket.gethostname(), self._port))
        except:
            Logger("Can't connect to the daemon", "WARN")
            return None
        else:
            return connection

    def _check_ok_connection (self):
        # OK connection
        okconn = self._est_daemon_connection()

        if okconn is None:
            return False
        else:
            okmsg = okconn.recv(2)
            if okmsg.decode() == "OK":
                Logger("Got the OK, now disconnecting")
                okconn.shutdown(socket.SHUT_RDWR)
                okconn.close()
            else:
                Logger("Got something else: \"" + okmsg.decode() + "\"", "WARN")
                return False

        return True

    def _launch_daemon (self):

        pid = os.fork()

        if pid == 0: # child

            os.setsid()
            # closing stdin, stdout, and stderr
            for i in [0, 1, 2]:
                try:
                    os.close(i)
                except:
                    pass

            pid = os.fork()

            if pid > 0: # parent, just exit
                exit()
            else: # grand child, do the daemon suff
                self.daemon.run()

        # TODO: make sure the daemon started succesfully
        Logger("sleeping for 10 ms, waiting for the daemon to start")
        time.sleep(0.01)

        return self._check_ok_connection()

    def _connect (self):
        pass
        return

    def _is_running (self):
        pass
        return

    # def _is_connected (self):
    #     pass
    #     return

    def restart (self):
        pass
        return

    # Call this everytime the client starts.
    # And this will take care of starting the daemon
    # (if it's not running) and attaching to the daemon
    def connect (self):

        if self._is_connected:
            return True

        print("ok")

        if self._launch_daemon():
            Logger("Launched the daemon, daemon is waiting for connections")
        else:
            Logger("Failed to launch the daemon, returning", "WARN")
            return

        Logger("Establishing the status connection")

        self.status_socket = self._est_daemon_connection()
        if self.status_socket is None:
            Logger("Failed to establish the status connection", "WARN")

        # TESTING: we won't be doing anything with the command_socket at the moment
        self.command_socket = self._est_daemon_connection()
        if self.command_socket is None:
            Logger("Failed to establish the command connection", "WARN")

        while True:

            Logger("Reciving a new status")
            size = self.status_socket.recv(4)
            if size == b'':
                Logger("Recieved a null byte probably the daemon got disconnected", "WARN")
                break

            Logger("Got a size")

            size = self._cal_payload_size(size)

            Logger("Recived one, size of the payload: " + str(size))
            payload = self.status_socket.recv(size)

            if payload == b'':
                Logger(
                    "Recived a null byte probably the daemon got disconnected before sending the payload",
                    "WARN"
                )
                break

            status = json.loads(payload.decode())

            print(status)


        ### if not self._is_running():
        ###     if not self._launch():
        ###         return False

        ### return self._connect()


class SpotLrc():

    _url_base = "https://lrclib.net/api/search?"

    def __init__ (self, lrc_dir):

        if os.path.isdir(lrc_dir):
            self.lrc_dir = lrc_dir
            try:
                os.mkdir(lrc_dir + "/json")
            except FileExistsError:
                pass
            try:
                os.mkdir(lrc_dir + "/lyrics")
            except FileExistsError:
                pass
            try:
                os.mkdir(lrc_dir + "/plain")
            except FileExistsError:
                pass
        else:
            Logger("Directory doesn't exists.")
        pass

        return

    def _fix_artist (self, file):

        artists = file["TPE1"].text[0]
        new_artists = ""
        write = False

        for char in artists:
            if char == "/":
                write = True
                new_artists = new_artists + ","
            else:
                new_artists = new_artists + char

        if write:
            file["TPE1"] = TPE1(text = new_artists)

        return

    def _query_lrclib (self, params):

        synced = None
        plain = None

        url = self._url_base + params
        response = requests.get(url)
        if not response.ok:
            Logger(
                "Got no lrc, response status: " + str(response.status_code)
            )
            return (None, None, None)

        Logger("Got a response...")

        if response.text == "[]":
            return (None, None, None)

        for result in json.loads(response.text):
            if synced is None:
                if result["syncedLyrics"] is not None:
                    Logger("Got a synced lyrics...")
                    synced = re.sub("\] ", "]", result["syncedLyrics"])
            if plain is None:
                if result["plainLyrics"] is not None:
                    Logger("Got a plain lyrics...")
                    plain = result["plainLyrics"]

        return (synced, plain, response)

    def _create_pe_tbl (self, track_name, artist_name, album_name, duration):

        pe_tbl = []

        ####
        param = urllib.parse.urlencode({
            "track_name": track_name,
            "artist_name": artist_name,
            "album_name": album_name,
            "duration": duration
        })

        pe_tbl.append({
            "param": param,
            "error": "Got an empty response, trying again with the track name and artist name..."
        })

        ####
        param = urllib.parse.urlencode({
            "track_name": track_name,
            "artist_name": artist_name,
        })

        pe_tbl.append({
            "param": param,
            "error": "Got an empty response, trying again with the track name and album name..."
        })

        ####
        param = urllib.parse.urlencode({
            "track_name": track_name,
            "album_name": album_name,
        })

        pe_tbl.append({
            "param": param,
            "error": "Got an empty response again, trying again with track name and the cleaned album name..."
        })

        ####
        cleaned_album_name = re.sub("\(( *)?From ?", "", album_name)
        cleaned_album_name = re.sub(" ?\)", "", cleaned_album_name)
        cleaned_album_name = re.sub("[^a-zA-Z0-9 ]", "", cleaned_album_name)

        param = urllib.parse.urlencode({
            "q": track_name + "+" + cleaned_album_name,
        })

        pe_tbl.append({
            "param": param,
            "error": "Got an empty response again, trying again with just the track name..."
        })

        ####
        param = urllib.parse.urlencode({
            "track_name": track_name
        })

        pe_tbl.append({
            "param": param,
            "error": "Still got an empty response, cleaning the title and trying once more..."
        })

        ####
        cleaned_track_name = re.sub(" ?\(.*\) ?", "", track_name)
        cleaned_track_name = re.sub("[^a-zA-Z0-9 ]", "", cleaned_track_name)

        param = urllib.parse.urlencode({
            "track_name": cleaned_track_name
        })

        pe_tbl.append({
            "param": param,
            "error": "Sorry, still got nothing..."
        })

        return pe_tbl

    def _del_uslt_tags (self, file):

        tags_to_del = []

        for key in file.keys():
            if key[0:4] == "USLT":
                tags_to_del.append(key)

        for key in tags_to_del:
            file.pop(key)

    def get_lrc (self, file_list):

        track_name = None
        artist_name = None
        album_name = None
        duration = None

        file_stem = None

        for file_path in file_list:

            file = ID3(file_path)

            file_stem = os.path.splitext(os.path.basename(file_path))[0]

            Logger(file_path)
            Logger("Querying for " + file["TIT2"].text[0] + " - " + file["TPE1"].text[0] + "...")

            Logger("Fixing artists...")
            self._fix_artist(file)
            Logger("Deleting other USLT tags...")
            self._del_uslt_tags(file)

            track_name = file["TIT2"].text[0]
            artist_name = file["TPE1"].text[0]
            album_name = file["TALB"].text[0]
            duration = str(int(int(file["TLEN"].text[0]) / 1000))

            pe_tbl = self._create_pe_tbl(
                track_name,
                artist_name,
                album_name,
                duration
            )

            synced = None
            plain = None
            response = None

            for pe in pe_tbl:
                res = self._query_lrclib(pe["param"])

                if synced is None:
                    synced = res[0]

                if plain is None:
                    plain = res[1]

                response = res[2]
                if synced is None or plain is None:
                    Logger(pe["error"])
                else:
                    break

            if response is not None:
                # TODO: give proper file names instead to slamming file_stem
                with open(self.lrc_dir + "/json/" + file_stem + ".json", "w") as tmp_file:
                    tmp_file.write(response.text)
            else:
                Logger("No response at all, weird...", "WARN")

            if synced is not None:
                file.add(USLT(text = synced, desc = "synced"))
                with open(self.lrc_dir + "/lyrics/" + file_stem + ".lrc", "w") as tmp_file:
                    tmp_file.write(synced)
                    tmp_file.write("\n")
            else:
                Logger("Haven't got the synced lyrics...")

                if plain is not None:
                    file.add(USLT(text = plain, desc = "plain"))

            if plain is not None:
                with open(self.lrc_dir + "/plain/" + file_stem + ".lrc", "w") as tmp_file:
                    tmp_file.write(plain)
                    tmp_file.write("\n")
            else:
                Logger("Haven't got the plain lyrics...")

            file.save()

def parse_config():

    global Config_Dir
    global Music_Dir
    global Lyrics_Dir
    global Api_Id
    global Api_Hash

    Config_Dir = os.path.expandvars(Config_Dir)

    config_file = Config_Dir + "/config.ini"
    if not os.path.isfile(config_file):
        print("Config file is not present: " + config_file)
        print("Inorder to sdl to work, you need the Telegram Api Id and Hash")
        print("Exiting...")
        exit()

    config = configparser.ConfigParser()
    config.read(config_file)

    Music_Dir = os.path.expandvars(config["download"]["MusicDir"])

    if not os.path.isdir(Music_Dir):
        print("Directory doesn't exists: " + Music_Dir)
        print("Please make sure you have specified the right directory to download files.")
        print("Exiting...")
        exit()

    Lyrics_Dir = os.path.expandvars(config["download"]["LyricsDir"])

    if not os.path.isdir(Lyrics_Dir):
        print("Directory doesn't exists: " + Lyrics_Dir)
        print("Please make sure you have specified the right directory to download lyrics.")
        print("Exiting...")
        exit()

    Api_Id = int(config["telegram.api"]["Id"])
    Api_Hash = config["telegram.api"]["Hash"]


def download():

    pat = re.compile("^(https://open\.spotify\.com/([^/]+)/.{22})(\?)?(.*)$")

    query = ""
    downloaded_list = None

    if len(sys.argv) == 2 and (sys.argv[1] == "--clip" or sys.argv[1] == "-c"):
        clip = subprocess.Popen(
            ["termux-clipboard-get"], stdout = subprocess.PIPE
        )

        clip = clip.stdout.read().decode()

        mat = pat.match(clip)

        if mat is not None:

            url_type = None

            grps = mat.groups()

            if grps[1] == "album":
                url_type = "album"
            elif grps[1] == "track":
                url_type = "track"
            elif grps[1] == "playlist":
                url_type = "playlist"
            else:
                Logger("Currently only albums and tracks can be downloaded, exiting...")
                Logger("Clipboard contents: \"" + clip + "\"")
                exit()
        else:
            Logger("Clipboard does not contain a valid url, exiting...")
            Logger("Clipboard contents: \"" + clip + "\"")
            exit()

        sdl = SpotDownload(Config_Dir + "/anon", Api_Id, Api_Hash)
        downloaded_list = sdl.download([(grps[0], url_type)])
    else:
        if len(sys.argv) > 1:

            query = sys.argv[1]

            for arg in sys.argv[2:]:
                query = query + " " + arg
        else:
            print("Query: ", end = "")
            query = input()

        if query == "":
            Logger("No query, exiting...")
            exit()

        squery = SpotQuery(query)

        if squery.gen_result() is None:
            Logger("No selections were generated, exiting...")
            exit()

        sdl = SpotDownload(Config_Dir + "/anon", Api_Id, Api_Hash)
        downloaded_list = sdl.download([(squery.get_url(), squery.get_type())])

    lrc = SpotLrc(Lyrics_Dir)
    lrc.get_lrc(downloaded_list)

    return

# https://open.spotify.com/track/7nHQjVpEncX7NEdA2G6kU1
# https://open.spotify.com/track/7nHQjVpEncX7NEdA2G6kU1


# main()

def attach_lrc ():

    fzf = FzfPrompt()

    files = [file for file in os.listdir(Music_Dir) if file[-4:] == ".mp3"]
    files.sort(key = lambda x: os.path.getmtime(os.path.join(Music_Dir, x)))

    selected = [os.path.join(Music_Dir, file) for file in fzf.prompt(files, "--tac -m")]

    lrc = SpotLrc(Lyrics_Dir)
    lrc.get_lrc(selected)

parse_config()

# sq = SpotQuery("taylor swift songs")
sdl = SpotClient(Config_Dir + "/anon", Api_Id, Api_Hash)

print(sdl.connect())

### if len(sys.argv) == 2 and (sys.argv[1] == "--lrc" or sys.argv[1] == "-l"):
###     attach_lrc()
### else:
###     download()

# sdl = SpotDownload(Config_Dir + "/anon", Api_Id, Api_Hash)
# downloaded_list = sdl.download(
#     [("https://open.spotify.com/playlist/2oyDrQfkkSMdyXPXKKHm1t", "playlist")]
# )

# https://open.spotify.com/track/2Fxmhks0bxGSBdJ92vM42m
# lrc = SpotLrc(".")
# lrc.get_lrc(["/data/data/com.termux/files/home/storage/shared/Music/sdl/Emei - Scatterbrain.mp3"])
