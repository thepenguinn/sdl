#!/data/data/com.termux/files/usr/bin/python

from telethon import TelegramClient, events, tl

from pyfzf.pyfzf import FzfPrompt
from concurrent.futures import ThreadPoolExecutor
from mutagen.id3 import ID3, USLT, TPE1
from bs4 import BeautifulSoup
from pprint import pprint
from enum import Enum

import configparser
import subprocess
import threading
import requests
import asyncio
import urllib
import socket
import json
import time
import sys
import re
import os

Config_Dir = "${HOME}/.config/sdl"

Api_Id = None
Api_Hash = None

Music_Dir = None
Lyrics_Dir = None

MIN_CHUNK_SIZE = 4096
CHUNK_COUNT = 256
REQUEST_SIZE = MIN_CHUNK_SIZE * CHUNK_COUNT

def Logger(msg, level = "LOG"):
    print(msg)

class SpotQuery:

    _re_pat = None
    _fzf = None
    _headers = {"user-agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) QtWebEngine/5.15.3 Chrome/87.0.4280.144 Safari/537.36"}


    def __init__ (self, query):

        if SpotQuery._re_pat is None:
            SpotQuery._re_pat = re.compile("^(https://open\.spotify\.com/(.+)/.{22})(\?)?(.*)$")
        if SpotQuery._fzf is None:
            SpotQuery._fzf = FzfPrompt()
        self.query = query
        self.query_results = None

        return

    def _get_index (self, line):
        end = 0
        for i in range(len(line) - 1):
            if line[i] == " ":
                end = i
                break

        return int(line[0:end])

    def _create_url (self, query):

        new = ""
        for i in query:
            if i == " ":
                new = new + "+"
            else:
                new = new + i
        query = new

        return "https://www.google.com/search?q=" + query + "+spotify&ei=JVlSYtHCA-6MseMPwNGeiAc&ved=0ahUKEwiR6fbF0Ij3AhVuRmwGHcCoB3EQ4dUDCA4&uact=5&oq=" + query + "+spotify&gs_lcp=Cgdnd3Mtd2l6EANKBAhBGABKBAhGGABQAFi1c2C5dmgEcAF4AIAByQGIAfkikgEGMC4zMC4xmAEAoAEBwAEB&sclient=gws-wiz"

    def _refine_link (self, link):

        # only works if we don't pass the headers
        res = requests.get(link["url"])

        if not res.ok:
            Logger("Spotify query failed", "WARN")
            return link

        soup = BeautifulSoup(res.text, "html.parser")

        for meta in soup.find_all("meta"):
            if meta.has_attr("name") and meta["name"] == "twitter:title":
                if meta.has_attr("content") and meta["content"] != "":
                    link["title"] = meta["content"]
                    return link


    def query_from_google (self, query):

        Logger("query_from_google")

        if query is None:
            None

        query_results = []

        url = self._create_url(query)

        res = requests.get(url, headers = self._headers)

        if not res.ok:
            Logger("Google query failed", "WARN")
            return None

        with open("google.html", "w") as f:
            f.write(res.text)

        soup = BeautifulSoup(res.text, "html.parser")

        for h3 in soup.find_all("h3"):
            if h3.parent.has_attr("href"):
                title = h3.text
                mat = self._re_pat.match(h3.parent["href"])

                if mat is None:
                    continue

                groups = mat.groups()

                if groups[1] == "album":
                    res_type = "album"
                elif groups[1] == "track":
                    res_type = "track"
                else:
                    continue

                query_results.append(
                    self._refine_link({
                        "url": groups[0],
                        "type": res_type,
                        "title": title
                    })
                )

        if len(query_results) > 0:
            return query_results
        else:
            return None

    def query_by_album_from_spotify (self, album_url):

        # queries the songs of the album, but not sure whether
        # this will return all of the tracks if the album has a
        # track count larger the 30 songs. This will be usefull
        # to get the albums having a single track.

        query_results = []

        # only works if we don't pass the headers
        res = requests.get(album_url)

        if not res.ok:
            Logger("Spotify query failed", "WARN")
            return None

        soup = BeautifulSoup(res.text, "html.parser")

        for div in soup.find_all("div"):
            if div.has_attr("aria-label"):
                # TODO: make sure this url is actually a track url
                query_results.append({
                    "title": div["aria-label"],
                    "url": re.sub(
                        "^.*track:", "https://open.spotify.com/track/", div["aria-labelledby"]
                    ),
                    "type": "track"
                })

        if len(query_results) > 0:
            return query_results
        else:
            Logger("Got no tracks", "WARN")
            return None

    def _is_in (self, val, lis, key):

        idx = -1

        for i in range(len(lis)):
            if lis[i][key] == val:
                idx = i
                break

        return idx


    def query_by_track_from_spotify (self, track_url, google_results):

        # queries the track from spotify, this hopefully returns
        # the album and the related tracks.

        query_results = []

        # only works if we don't pass the headers
        res = requests.get(track_url)

        if not res.ok:
            Logger("Spotify query failed", "WARN")
            return None

        soup = BeautifulSoup(res.text, "html.parser")

        for div in soup.find_all("div"):
            if div.text[0:6] == "Single":
                parent = div.find_parent()
                if parent.has_attr("href"):
                    Logger("Got a Song")

                    title = None
                    for child in parent.children:
                        if child.has_attr("dir"):
                            title = child.text
                            break
                    if title is None:
                        Logger("Haven't got a title", "WARN")

                    url = "https://open.spotify.com" + parent["href"]
                    url_type = None

                    if parent["href"][0:6] == "/album":
                        Logger("The song has an album url, querying for the track url")
                        url_list = self.query_by_album_from_spotify(url)

                        if url_list is None:
                            Logger("query_by_album_from_spotify() returned nothing", "WARN")

                        idx = self._is_in(url_list[0]["url"], google_results, "url")

                        if idx > -1:
                            Logger("This url is in the google results")
                            if len(google_results[idx]["title"]) < len(url_list[0]["title"]):
                                Logger("New title is bigger than old, so updating")
                                Logger("Old: " + google_results[idx]["title"])
                                Logger("New: " + url_list[0]["title"])
                                google_results[idx]["title"] = url_list[0]["title"]
                            continue

                        if len(url_list) == 1:
                            if url_list[0]["type"] == "track":
                                Logger("Got the track url")
                                url = url_list[0]["url"]
                                url_type = "track"
                            else:
                                Logger("Haven't got a track url, instead got a " + url_list[0]["url"], "WARN")
                        elif len(url_list) > 1:
                            Logger("query_by_album_from_spotify() returned more than one links, merging it with the results")
                            query_results = query_results + url_list
                            continue

                    elif parent["href"][0:6] == "/track":
                        Logger("The song has an track url")
                        url_type = "track"
                    else:
                        Logger("The song neither has a track url or an album url", "WARN")

                    if url is not None and url_type is not None and title is not None:
                        query_results.append({
                            "title": title,
                            "url": url,
                            "type": url_type
                        })
                        print("")
                    else:
                        Logger("One of url, url_type, and title was None", "WARN")


            elif div.text[0:5] == "Album":

                parent = div.find_parent()

                if parent.has_attr("href"):
                    Logger("Got an Ablum")

                    title = None
                    for child in parent.children:
                        if child.has_attr("dir"):
                            title = child.text
                            break
                    if title is None:
                        Logger("Haven't got a title", "WARN")

                    if parent["href"][0:6] == "/album":
                        url_type = "album"
                    else:
                        Logger("url is not a album url", "WARN")
                        url_type = None

                    url = "https://open.spotify.com" + parent["href"]

                    if url is not None and url_type is not None and title is not None:
                        query_results.append({
                            "title": title,
                            "url": url,
                            "type": url_type
                        })
                        print("")
                    else:
                        Logger("One of url, url_type, and title was None", "WARN")

        if len(query_results) > 0:
            return query_results
        else:
            Logger("Got no links", "WARN")
            return None


    def query_from_spotify (self, url, url_type, google_results):

        if url_type == "track":
            return self.query_by_track_from_spotify(url, google_results)
        elif url_type == "ablum":
            return self.query_by_album_from_spotify(url)
        else:
            Logger("Currently only tracks and albums can be queried from spotify", "WARN")
            return None

    def query_links (self, query):

        if query is None:
            return None

        gres = self.query_from_google(query)

        if gres is None:
            return None

        sres = None

        for link in gres:
            if link["type"] == "track":
                print(link["url"])
                sres = self.query_from_spotify(link["url"], link["type"], gres)
                break

        if sres is not None:
            gres = gres + sres

        return gres

    def prompt_user (self, query_list):

        fzf_list = []
        idx = 0


        for res in query_list:
            if res["type"] == "album":
                url_type = "Album"
            elif res["type"] == "track":
                url_type = "Track"
            elif res["type"] == "playlist":
                url_type = "Playlist"
            else:
                url_type = "Umm"
            fzf_list.append(str(idx) + " " + url_type + ": " + res["title"])
            idx = idx + 1

        sel = self._fzf.prompt(fzf_list, "--with-nth 2..")

        if not sel:
            return None

        sel_idx = self._get_index(sel[0])

        return query_list[sel_idx]


    def gen_result (self):

        if self.query_results is None:
            self.query_results = self.query_links(self.query)
            if self.query_results is None:
                Logger("No query results were generated from google", "WARN")
                return None

        self.selected_query_result = self.prompt_user(self.query_results)

        return self.selected_query_result

    def get_url (self, result = None):
        if result is None:
            result = self.selected_query_result
        return result["url"]

    def get_type (self, result = None):
        if result is None:
            result = self.selected_query_result
        return result["type"]

    def get_title (self, result = None):
        if result is None:
            result = self.selected_query_result
        return result["title"]

class SpotDaemon:

    client = None

    # TESTING
    Status = Enum(
        "Status", [
            "LOG",
            "WARN",
            "SEND",
            "PROGRESS",
            "FAILED",
            "SUCCESS",
        ]
    )

    Command = Enum(
        "Command", [
            "ADD",
            "STOP",
        ]
    )

    UrlType = Enum(
        "UrlType", [
            "PLAYLIST",
            "ALBUM",
            "TRACK"
        ]
    )

    DownloadStatus = Enum(
        "DownloadStatus", [
            "SUCCESS",
            "FAILURE",
            "INVALID",
        ]
    )

    def __init__ (self, session, api_id, api_hash, port, backlog = 5):

        self._session = session
        self._api_id = api_id
        self._api_hash = api_hash
        self._port = port
        self._backlog = backlog

        return

    def _init (self):

        # TESTING #
        ### if self.client == None:
        ###     self.client = TelegramClient(
        ###         self._session, self._api_id, self._api_hash
        ###     )

        if self._daemon_logger_file_fd is None:
            self._daemon_logger_file_fd = open(self._daemon_logger_file_path, "w")
            self._daemon_logger_file_fd.write("Aloha!\n")

        # Everything that related with downloading files
        self._last_download_status = self.DownloadStatus.FAILURE
        self._last_album_track_count = 0
        self._last_album_title = ""
        self._last_album_artist = ""
        self._last_album_download_count = 0
        self._one_photo_recieved = False
        self._one_track_recieved = False
        self._download_list = None
        self._clicked_button = False
        self._last_download_files = None
        self._last_playlist_download_count = 0

        # Status Logger
        self._status_logger_file_fd = open("status.log", "w")
        self._status_conn_broke = False
        self._status_pending = []

        # Everything that relate to daemon
        self._is_connected = False
        self._daemon_logger_file_path = "daemon.log"
        self._daemon_logger_file_fd = None

        # TESTING #
        # _data_lock will take care of the synchronization of data structures
        self.query_list = []
        self.info_list = []
        self.download_list = []

        # For syncing with the client, as long as this lock is locked
        # the daemon shouldn't modify the above data structures.
        self._ack_lock = None

        self.stop_download = False

        return

    def _set_last_album_info (self, msg_text):

        lend = 0
        lstart = 0

        while msg_text[lend] != "\n":
            lend += 1

        self._last_album_title = msg_text[9:lend]

        lend += 1
        lstart = lend

        while msg_text[lend] != "\n":
            lend += 1

        self._last_album_artist = msg_text[lstart+10:lend]

        lend += 1
        lstart = lend
        while msg_text[lend] != "\n":
            lend += 1
        lend += 1
        lstart = lend

        self._last_album_track_count = int(msg_text[lstart+16:])

        return

    def _curate_files (self):

        if len(self._last_download_files) < 1:
            Logger("It seems like no files have been downloaded.", "WARN")
            return

        termuxcmd = ["termux-media-scan"]

        subprocess.run(termuxcmd + self._last_download_files)

        return

    def _to_mb_str_bytes(self, size):
        return "%05.2f MB"%((size / 1024) / 1024)

    def _prog_callback(self, current, total):
        time_taken = time.time() - self._download_start_time
        speed_kb = "%d KB/s" % (int((current / time_taken) / 1024))
        percent = "% 6.2f%%" % (current / total * 100)
        bars = int((current / total * 100) / 5)
        bar_str = f' {"#"*bars:<20} '

        print(percent + bar_str + speed_kb + " | " + self._to_mb_str_bytes(current) + " / " + self._to_mb_str_bytes(total), end = "\r")

        return

    async def _status_logger (self, message, level = None):

        if level is None:
            level = self.Status.LOG

        cur_time = time.monotonic()

        # if level == Status.LOG:
        # elif level == self.Status.WARN:
        # elif level == Status.SEND:
        # elif level == Status.PROGRESS:
        # elif level == Status.FAILED:
        # elif level == Status.SUCCESS:
        # else:

        status = {
            "level": level.value,
            "time": cur_time,
            "message": message
        }

        payload = json.dumps(status).encode()

        size = len(payload)

        header = bytearray([
            size & 0xff, (size >> 8) & 0xff, (size >> 16) & 0xff, (size >> 24) & 0xff
        ])

        try:
            await self._loop.run_in_executor(
                self._pool, self._ack_lock.acquire
            )
            self._status_lock.acquire()
            self._status_socket.send(header + payload)

        except Exception as e:
            # self._status_logger_file_fd.write(e.args[0])
            # self._status_logger_file_fd.flush()
            await self._loop.run_in_executor(
                self._pool, self._data_lock.acquire
            )
            self._status_pending.append(status)
        else:
            # the client to send an 'ACK' after receving every status
            # the client should only send 'ACK' after syncing the data
            # if, the status updaate was related to the mutation of the
            # data.
            ack = self._status_socket.recv(3)
            if ack.decode() == "ACK":
                self._status_logger_file_fd.write(
                    self.Status.WARN.name ": " + str(cur_time) + ": " + "Got the 'ACK'" + "\n"
                )
            else:
                self._status_logger_file_fd.write(
                    self.Status.WARN.name ": " + str(cur_time) + ": " + "Didn't recieve 'ACK'" + "\n"
                )
            self._status_logger_file_fd.flush()

        finally:
            if self._ack_lock.locked():
                self._ack_lock.release()
            if self._status_lock.locked():
                self._status_lock.release()
            # TODO: _data_lock is the only lock that may or may not be locked
            if self._data_lock.locked():
                self._data_lock.release()

        self._status_logger_file_fd.write(
            level.name + ": " + str(cur_time) + ": " + str(message) + "\n"
        )
        self._status_logger_file_fd.flush()

        return

    async def _download_audio (self, msg, track):

        file_name = ""
        for i in msg.file.name:
            if i == "\"" or i == ":" or i == "?":
                file_name = file_name + " "
            else:
                file_name = file_name + i
        file_name = Music_Dir + "/" + file_name

        if os.path.isfile(file_name):
            await self._status_logger("File exists, skipping the download", self.Status.WARN)
            return

        self._last_download_files.append(file_name)

        tmp_file_fd = None
        download_size = 0

        tmp_file_name = Music_Dir + "/" + str(msg.document.id) + ".temp"

        if os.path.isfile(tmp_file_name):
            await self._status_logger("Temp file exists, resuming download...")
            tmp_file_fd = open(tmp_file_name, "ab")
            download_size = tmp_file_fd.tell()
            if msg.document.size == download_size:
                await self._status_logger("File is already downloaded")
            elif int(download_size / REQUEST_SIZE) * REQUEST_SIZE != download_size:
                await self._status_logger(
                    "Temp file size is not a multiple o REQUEST_SIZE\n"
                        + "Request Size: " + str(REQUEST_SIZE)
                        + ", Downloaded Size: " + str(download_size)
                )
        else:
            await self._status_logger("Starting a fresh download...")
            tmp_file_fd = open(tmp_file_name, "wb")

        # print("File: " + file_name + " | Size: " + self._to_mb_str_bytes(msg.document.size))

        self._download_start_time = time.time()
        async for chunk in self.client.iter_download(
            msg.document, offset = download_size, request_size = REQUEST_SIZE):

            download_size += len(chunk)
            tmp_file_fd.write(chunk)

            await self._status_logger(download_size)
            await self._loop.run_in_executor(
                self._pool, self._data_lock.acquire
            )
            track["downloaded_bytes"] = download_size
            self._data_lock.release()
            # self._prog_callback(download_size, msg.document.size)
        # print("")

        tmp_file_fd.close()

        if download_size == msg.document.size:
            os.rename(tmp_file_name, file_name)
        else:
            await self._status_logger(
                "Size of the downloaded file doesn't match with the size from Telegram,\nprobably corrupted",
                self.Status.WARN
            )

        return

    async def _test_iter_download(self, delay = 1, gaps = 10):

        for i in range(gaps):
            await asyncio.sleep(delay)
            yield i
        return

    async def _test_download_audio (self, msg, track):

        async for chunck in self._test_iter_download():
            await self._status_logger(chunk)
            await self._loop.run_in_executor(
                self._pool, self._data_lock.acquire
            )
            track["downloaded_bytes"] = chunk
            self._data_lock.release()

        return

    async def _add_to_info_list (self, message):

        track = {
            "message": message,
            "file_name": message.file.name,
            "file_id": message.file.id,
            "artist_name": message.file.performer,
            "track_name": message.file.title,
            "downloaded_bytes": 0,
            "total_bytes": message.file.size,
            "duration": message.file.duration,
            "discarded": False
        }

        await self._loop.run_in_executor(
            self._pool, self._data_lock.acquire
        )
        # we will just append the track to the last element of info list

        idx = len(self.info_list) - 1
        if idx < 0:
            await self._status_logger(
                "info_list is empty, this shouldn't happen",
                self.Status.WARN
            )
            return

        self.info_list[idx]["tracks"].append(track)

        self._data_lock.release()

        self.info_event.set()

        return

    async def _album_download_handler (self, event):
        await event.mark_read()
        if event.message.message == "Invalid link ;)":
            await self._status_logger("Link was Invalid. Disconnecting...")
            self._last_download_status = self.DownloadStatus.FAILURE
            self.handler_event.set()

        if event.audio:
            if not self._clicked_button:
                await self._status_logger("Directly recieving the tracks")
                self._clicked_button = True

            await self._add_to_info_list(event)
            # await self._download_audio(event)
            self._last_album_download_count += 1
            if self._last_album_track_count == self._last_album_download_count and self._one_photo_recieved:
                await self._status_logger("Downloaded all the tracks. Disconnecting...")
                self._last_download_status = self.DownloadStatus.SUCCESS
                await self._status_logger("Dettaching album download handler...")
                self.client.remove_event_handler(
                    self._album_download_handler
                )
                self.handler_event.set()
            return
        elif event.message.message == "Downloading…":
            await self._status_logger("Recived one message with a Downloading…")
            return
        elif event.buttons:

            if self._clicked_button:
                await self._status_logger("Got another message with buttons", self.Status.WARN)
                return

            # This must be the first msg if the url is a proper one
            self._set_last_album_info(event.message.message)
            await self._status_logger("Album Track Count: " + str(self._last_album_track_count))
            await self._status_logger("Message has buttons")
            for row in event.buttons:
                for btn in row:
                    if btn.text == "GET ALL ⬇️":
                        await self._status_logger("Clicking GET ALL button")
                        self._clicked_button = True
                        await btn.click()
            if not self._clicked_button:
                await self._status_logger("Seems like there were no GET ALL button")
                if self._last_album_track_count == 1:
                    await self._status_logger("Clicking the first button")
                    self._one_photo_recieved = True
                    self._clicked_button = True
                    await event.buttons[0][0].click()
                else:
                    await self._status_logger("Track Count is not 1, somethings wrong", self.Status.WARN)

        elif event.photo:
            if not self._clicked_button:
                await self._status_logger("Seems like we are recieving tracks directly")
                self._set_last_album_info(event.message.message)
                await self._status_logger("Album Track Count: " + str(self._last_album_track_count))
                self._clicked_button = True

            self._one_photo_recieved = True
            await self._status_logger("Recived one message with a photo")
            return


    async def _track_download_handler (self, event):
        await event.mark_read()
        if event.message.message == "Track not found." or event.message.message == "Invalid link ;)":
            if event.message.message == "Track not found.":
                await self._status_logger("Track no found. Disconnecting...", self.Status.WARN)
            else:
                await self._status_logger("Link was Invalid. Disconnecting...", self.Status.WARN)
            self._last_download_status = self.DownloadStatus.FAILURE
            self.handler_event.set()

        if event.audio:
            await self._status_logger("Recived one message with an audio")
            self._one_track_recieved = True
            await self._add_to_info_list(event)
            # await self._download_audio(event)

        if event.photo:
            await self._status_logger("Recived one message with a photo")
            self._one_photo_recieved = True

        if self._one_photo_recieved and self._one_track_recieved:
            await self._status_logger("Recieved the track and the photo. Disconnecting...")
            self._last_download_status = self.DownloadStatus.SUCCESS
            await self._status_logger("Dettaching track download handler...")
            self.client.remove_event_handler(
                self._track_download_handler
            )
            self.handler_event.set()
        return

    async def _playlist_download_handler (self, event):
        await event.mark_read()
        if event.message.message == "Invalid link ;)":
            await self._status_logger("Link was Invalid. Disconnecting...")
            self._last_download_status = self.DownloadStatus.FAILURE
            self.handler_event.set()

        if event.buttons:
            if self._clicked_button:
                await self._status_logger("Got another message with buttons.", self.Status.WARN)
                if event.message.message == "Downloading…":
                    await self._status_logger("Its the Downloading message")
                else:
                    await self._status_logger("Its not the Downloading message", self.Status.WARN)
                return

            if event.buttons[0][0].text == "GET ALL ⬇️":
                await self._status_logger("Clicking GET ALL button")
                self._clicked_button = True
                await event.buttons[0][0].click()
        elif event.audio:
            await self._add_to_info_list(event)
            self._last_playlist_download_count += 1
        elif event.message.message == "Finished.":
            await self._status_logger("Downloaded all the tracks. Disconnecting...")
            self._last_download_status = self.DownloadStatus.SUCCESS
            await self._status_logger("Dettaching playlist download handler...")
            self.client.remove_event_handler(
                self._playlist_download_handler
            )
            # print(self._last_playlist_download_count)
            self.handler_event.set()
        else:
            await self._status_logger("Recieved some other message", self.Status.WARN)
            print(event.message.message)

        return

    def _daemon_logger (self, msg, level = "LOG"):
        self._daemon_logger_file_fd.write(msg + "\n")
        self._daemon_logger_file_fd.flush()
        return

    async def _query_task_handler (self, info_event, query_event):

        cur_idx = 0

        # the handers will clear this event, once they are done
        # handling the query
        self.handler_event = asyncio.Event()

        # when the handlers add a new track to the info list
        # _add_to_info_list can simply self.info_event.clear() this event.
        # And I don't think we can pass other arguments to the event
        # handlers in any other way.
        self.info_event = info_event

        while True:
            await self._loop.run_in_executor(
                self._pool, self._data_lock.acquire
            )
            if len(self.query_list) > cur_idx:
                # query for the file and info
                query = self.query_list[cur_idx]
                url = query["url"]
                url_type = query["url_type"]

                self.info_list.append(
                    {
                        "url_type": url_type,
                        "tracks": [],
                        "discarded": False
                    }
                )

                self._data_lock.release()

                await self._status_logger("Sending the url to deezload2bot")
                await self.client.send_message(
                    "deezload2bot", url
                )

                # TODO: we probably don't need the .value
                if url_type == self.UrlType.TRACK.value:
                    await self._status_logger("Attaching track download handler...")
                    self.client.add_event_handler(
                        self._track_download_handler,
                        events.NewMessage(chats = [ 'deezload2bot' ], incoming = True)
                    )
                    self._one_track_recieved = False
                elif url_type == self.UrlType.ALBUM.value:
                    await self._status_logger("Attaching album download handler...")
                    self.client.add_event_handler(
                        self._album_download_handler,
                        events.NewMessage(chats = [ 'deezload2bot' ], incoming = True)
                    )
                    self._last_album_track_count = 0
                    self._last_album_title = ""
                    self._last_album_artist = ""
                    self._last_album_download_count = 0
                    self._clicked_button = False
                elif url_type == self.UrlType.PLAYLIST.value:
                    await self._status_logger("Attaching playlist download handler...")
                    self.client.add_event_handler(
                        self._playlist_download_handler,
                        events.NewMessage(chats = [ 'deezload2bot' ], incoming = True)
                    )
                    self._clicked_button = False
                    self._last_playlist_download_count = 0
                else:
                    # TODO: we still add this one as an invalid one
                    pass

                self._last_download_status = self.DownloadStatus.FAILURE
                self._last_download_files = []
                self._one_photo_recieved = False
                self._download_list = []

                await self._status_logger("Waiting for the reply from deezload2bot...")
                # the handler should set this event
                self.handler_event.clear()
                await self.handler_event.wait()

                # after

                if self._last_download_status == self.DownloadStatus.SUCCESS:
                    await self._status_logger("Succeded downloading the file(s)")
                    # TODO: do we really need to do this right now ?
                    self._curate_files()
                elif self._last_download_status == self.DownloadStatus.FAILURE:
                    # dettaching the handlers incase we failed
                    # TODO: move this from here to handlers, maybe ?
                    if url_type == self.UrlType.TRACK.value:
                        await self._status_logger("Dettaching track download handler...")
                        self.client.remove_event_handler(
                            self._track_download_handler
                        )
                    elif url_type == self.UrlType.ALBUM.value:
                        await self._status_logger("Dettaching album download handler...")
                        self.client.remove_event_handler(
                            self._album_download_handler
                        )
                    elif url_type == self.UrlType.PLAYLIST.value:
                        await self._status_logger("Dettaching playlist download handler...")
                        self.client.remove_event_handler(
                            self._playlist_download_handler
                        )
                    await self._status_logger(
                        "Failed downloading the file(s)", self.Status.WARN
                    )
                else:
                    # TODO: adflk
                    await self._status_logger(
                        "_last_download_status should have been either Success or Failed",
                        self.Status.WARN
                    )
                    await self._status_logger(
                        "Current value: " + self._last_download_status.name,
                        self.Status.WARN
                    )


                cur_idx += 1
                pass
            else:
                self._data_lock.release()
                # TODO: use threading event
                await self._loop.run_in_executor(
                    self._pool, query_event.wait
                )
        return

    async def _download_task_handler (self, info_event):

        while True:
            await self._loop.run_in_executor(
                self._pool, self._data_lock.acquire
            )
            if len(self.download_list) > 0:

                track = self.download_list[0]
                message = track["message"]

                self._data_lock.release()

                await self._test_download_audio(message, track)

                await self._loop.run_in_executor(
                    self._pool, self._data_lock.acquire
                )
                self.download_list.pop(0)
                self._data_lock.release()

            else:
                self._data_lock.release()
                await info_event.wait()

        return

    async def _async_download_thread_handler (self, query_event):

        info_event = asyncio.Event()

        download_task = asyncio.create_task(
            self._download_task_handler(info_event)
        )

        query_task = asyncio.create_task(
            self._query_task_handler(info_event, query_event)
        )

        await download_task
        await query_task

        return

    def _download_thread_handler (self, query_event):

        self._pool = ThreadPoolExecutor()
        self._loop = asyncio.get_event_loop()

        self.client.start()
        self.client.loop.run_until_complete(
            self._async_download_thread_handler(query_event)
        )

        return

    def _cal_payload_size (self, four_bytes):

        return four_bytes[0] | four_bytes[1] << 8 | four_bytes[2] << 16 | four_bytes[3] << 24

    def _command_thread_handler (self, command_socket, query_event):

        while True:
            # TESTING: this should block here till daemon got disconnected
            size = command_socket.recv(4)
            if size == b'':
                self._daemon_logger("It seems like the client got disconnected", "WARN")
                break

            size = self._cal_payload_size(size)
            self._daemon_logger( "size of the payload: " + str(size), "WARN")
            payload = command_socket.recv(size)
            if payload == b'':
                self._daemon_logger(
                    "It seems like the client got disconnected, before sending the payload",
                    "WARN"
                )
                break

            command = json.loads(payload.decode())

        self._daemon_logger("Leaving the _command_thread_handler loop", "WARN")

        return

    def _daemon_server_init(self, port, backlog):
        # TODO: handle exceptions
        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server.bind((socket.gethostname(), port))
        server.listen(backlog)

        return server

    def run (self):
        # daemon

        self._init()

        self._stop_daemon = False

        self._daemon_logger("Starting the server")
        server = self._daemon_server_init(self._port, self._backlog)
        self._daemon_logger("Succesfully initialized the server")

        # TODO: maybe move this to _init()
        self._status_lock = threading.Lock()
        self._data_lock = threading.Lock()
        self._ack_lock = threading.Lock()

        download_thread = None

        query_event = threading.Event()

        while True:

            self._daemon_logger("\nNew Connection\n")

            # ilomilo connection
            self._daemon_logger("Now accepting for ilomilo connection")
            client, addr = server.accept()

            self._daemon_logger("Client connected, sending 'ILO'")
            client.send("ILO".encode())

            self._daemon_logger("Now waiting for 'MILO'")

            msg = client.recv(4)

            if msg.decode() != "MILO":
                self._daemon_logger(
                    "\"The world's a little blurry, or maybe it's my eyes.\""
                )
                continue

            self._daemon_logger("Got the 'MILO', now waiting for the client to disconnect")
            # client should disconnect this connection
            msg = client.recv(1)
            if msg != b'':
                self._daemon_logger("Client keep sending something", "WARN")
            else:
                self._daemon_logger("Client got disconnected")

            # Actual connection
            self._daemon_logger("Initiating for the actual connection")
            self._daemon_logger("Waiting for the client to connect for the status connection")
            # this socket will be used to send the status, the client should
            # only be recving from this socket, DO NOT SEND anything.

            self._status_lock.acquire()
            self._status_socket, addr = server.accept()
            self._status_lock.release()
            self._daemon_logger("Client got connected")

            # we might not need a seperate thread for status.
            # we could just handle it from the download thread.
            # status_thread = Thread(target = self._status_thread_handler, args = [client])

            self._daemon_logger("Waiting for the client to connect for the command connection")
            # client can read and write from this connection
            # the daemon will respond to each of the commands through
            # this socket
            command_socket, addr = server.accept()
            self._daemon_logger("Client got connected")

            # status_socket should be a shared resource
            if download_thread is None:
                # this thread should never raise any exceptions that
                # means this thread should only stop when the daemon
                # is exiting
                download_thread = threading.Thread(
                    target = self._download_thread_handler,
                    args = [query_event]
                )

                self._daemon_logger("Starting the download thread")
                download_thread.start()

            # main thread will handle the command connection
            self._daemon_logger("Starting the command thread")
            self._command_thread_handler(command_socket, query_event)

            if self._stop_daemon:
                download_thread.join()
                break
            else:
                continue

            if not download_thread.is_alive():
                self._daemon_logger("download_thread is not alive, probably crashed", "WARN")
                break

        self._daemon_logger("Exiting...", "WARN")

        exit()

# do we need a SpotUi or just implement it in the Spotclient
class SpotUi:
    pass

class SpotClient:

    ui = None
    daemon = None

    def __init__ (self, session, api_id, api_hash, port = 49524):

        if self.daemon is None:
            self.daemon = SpotDaemon(session, api_id, api_hash, port)
        self._api_id = api_id
        self._api_hash = api_hash
        self._port = port
        self._daemon_is_connected = False

        # TESTING #
        # _data_lock will take care of the synchronization of data structures
        self.query_list = []
        self.info_list = []
        self.download_list = []

        return

    # TODO: you need a seperate function for this, huh?
    def _cal_payload_size (self, four_bytes):

        return four_bytes[0] | four_bytes[1] << 8 | four_bytes[2] << 16 | four_bytes[3] << 24

    def _est_daemon_connection (self):
        # this will block
        try:
            connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            connection.connect((socket.gethostname(), self._port))
        except:
            Logger("Can't connect to the daemon", "WARN")
            return None
        else:
            return connection

    def _ilomilo_connection (self):

        ilomilo = self._est_daemon_connection()

        if ilomilo is None:
            return False
        else:
            msg = ilomilo.recv(3)
            if msg.decode() == "ILO":
                Logger("Got the 'ILO', now sending 'MILO'")
                ilomilo.send("MILO".encode())
                Logger("Now disconnecting")
                ilomilo.shutdown(socket.SHUT_RDWR)
                ilomilo.close()
            else:
                Logger("Got something else: \"" + msg.decode() + "\"", "WARN")
                return False

        return True

    def _is_daemon_running (self):

        try:
            with open("pid") as f:
                pid = f.read()
        except FileNotFoundError:
            Logger("Couldn't read the pid of the daemon", "WARN")
            return False
        else:
            Logger("Got the pid of the daemon")

        try:
            with open("/proc/" + pid + "/status") as f:
                status = f.read()
        except FileNotFoundError:
            Logger("status file for the process does not exists", "WARN")
            return False
        else:
            Logger("Got the process status")

        process_name = ""

        try:
            for ch in status[6:]:
                if ch == "\n":
                    break
                else:
                    process_name = process_name + ch

        except:
            Logger("Failed to get the process name", "WARN")
            return False
        else:
            Logger("Got the process name")

        if process_name == "sdl":
            Logger("The daemon is running.")
            Logger("Proceeding for an ilomilo connection")
            return self._ilomilo_connection()
        else:
            Logger(
                "It's seems like it is different process\n"
                    + "process id: \"" + pid + "\" "
                    + "process name: \"" + process_name + "\"",
                "WARN"
            )
            return False
        return False

    def _launch_daemon (self):

        pid = os.fork()

        if pid == 0: # child

            os.setsid()
            # closing stdin, stdout, and stderr
            for i in [0, 1, 2]:
                try:
                    os.close(i)
                except:
                    pass

            pid = os.fork()

            if pid > 0: # parent, just exit
                # TESTING #
                with open("pid", "w") as f:
                    f.write(str(pid))
                exit()
            else: # grand child, do the daemon suff
                self.daemon.run()

        # TODO: make sure the daemon started succesfully
        Logger("sleeping for 10 ms, waiting for the daemon to start")
        time.sleep(0.01)

        return self._ilomilo_connection()

    # this is useless
    def _connect_to_daemon (self):

        while True:

            Logger("Reciving a new status")
            size = self._status_socket.recv(4)
            if size == b'':
                Logger("Recieved a null byte probably the daemon got disconnected", "WARN")
                break

            Logger("Got a size")

            size = self._cal_payload_size(size)

            Logger("Recived one, size of the payload: " + str(size))
            payload = self._status_socket.recv(size)

            if payload == b'':
                Logger(
                    "Recived a null byte probably the daemon got disconnected before sending the payload",
                    "WARN"
                )
                break

            status = json.loads(payload.decode())

            print(status)

        return

    def restart (self):
        pass
        return

    # Call this everytime the client starts.
    # And this will take care of starting the daemon
    # (if it's not running) and attaching to the daemon
    def connect (self):

        # this will prevent trying to connect to the already
        # connected daemon
        if self._daemon_is_connected:
            return True

        if not self._is_daemon_running():
            if not self._launch_daemon():
                return False

        Logger("Trying to establish the status connection")

        self._status_socket = self._est_daemon_connection()
        if self._status_socket is None:
            Logger("Failed to establish the status connection", "WARN")
            return False

        Logger("Trying to establish the command connection")

        # TESTING: we won't be doing anything with the command_socket at the moment
        self._command_socket = self._est_daemon_connection()
        if self._command_socket is None:
            Logger("Failed to establish the command connection", "WARN")
            return False

        self._daemon_is_connected = True

        # TESTING #
        self._connect_to_daemon()

        return True

    def _status_thread_handler (self):
        pass
        return

    def _input_thread_handler (self):

        while True:
            time.sleep(2)
        return

    # This will block, and only returns only if something happened
    # terribly, or when we are exiting.
    def run (self):
        # client

        if not self._daemon_is_connected:
            if not self.connect():
                return False

        status_thread = None
        input_thread = None

        draw_lock = Lock()
        data_lock = Lock() # err, maybe ?



        return

class SpotLrc():

    _url_base = "https://lrclib.net/api/search?"

    def __init__ (self, lrc_dir):

        if os.path.isdir(lrc_dir):
            self.lrc_dir = lrc_dir
            try:
                os.mkdir(lrc_dir + "/json")
            except FileExistsError:
                pass
            try:
                os.mkdir(lrc_dir + "/lyrics")
            except FileExistsError:
                pass
            try:
                os.mkdir(lrc_dir + "/plain")
            except FileExistsError:
                pass
        else:
            Logger("Directory doesn't exists.")
        pass

        return

    def _fix_artist (self, file):

        artists = file["TPE1"].text[0]
        new_artists = ""
        write = False

        for char in artists:
            if char == "/":
                write = True
                new_artists = new_artists + ","
            else:
                new_artists = new_artists + char

        if write:
            file["TPE1"] = TPE1(text = new_artists)

        return

    def _query_lrclib (self, params):

        synced = None
        plain = None

        url = self._url_base + params
        response = requests.get(url)
        if not response.ok:
            Logger(
                "Got no lrc, response status: " + str(response.status_code)
            )
            return (None, None, None)

        Logger("Got a response...")

        if response.text == "[]":
            return (None, None, None)

        for result in json.loads(response.text):
            if synced is None:
                if result["syncedLyrics"] is not None:
                    Logger("Got a synced lyrics...")
                    synced = re.sub("\] ", "]", result["syncedLyrics"])
            if plain is None:
                if result["plainLyrics"] is not None:
                    Logger("Got a plain lyrics...")
                    plain = result["plainLyrics"]

        return (synced, plain, response)

    def _create_pe_tbl (self, track_name, artist_name, album_name, duration):

        pe_tbl = []

        ####
        param = urllib.parse.urlencode({
            "track_name": track_name,
            "artist_name": artist_name,
            "album_name": album_name,
            "duration": duration
        })

        pe_tbl.append({
            "param": param,
            "error": "Got an empty response, trying again with the track name and artist name..."
        })

        ####
        param = urllib.parse.urlencode({
            "track_name": track_name,
            "artist_name": artist_name,
        })

        pe_tbl.append({
            "param": param,
            "error": "Got an empty response, trying again with the track name and album name..."
        })

        ####
        param = urllib.parse.urlencode({
            "track_name": track_name,
            "album_name": album_name,
        })

        pe_tbl.append({
            "param": param,
            "error": "Got an empty response again, trying again with track name and the cleaned album name..."
        })

        ####
        cleaned_album_name = re.sub("\(( *)?From ?", "", album_name)
        cleaned_album_name = re.sub(" ?\)", "", cleaned_album_name)
        cleaned_album_name = re.sub("[^a-zA-Z0-9 ]", "", cleaned_album_name)

        param = urllib.parse.urlencode({
            "q": track_name + "+" + cleaned_album_name,
        })

        pe_tbl.append({
            "param": param,
            "error": "Got an empty response again, trying again with just the track name..."
        })

        ####
        param = urllib.parse.urlencode({
            "track_name": track_name
        })

        pe_tbl.append({
            "param": param,
            "error": "Still got an empty response, cleaning the title and trying once more..."
        })

        ####
        cleaned_track_name = re.sub(" ?\(.*\) ?", "", track_name)
        cleaned_track_name = re.sub("[^a-zA-Z0-9 ]", "", cleaned_track_name)

        param = urllib.parse.urlencode({
            "track_name": cleaned_track_name
        })

        pe_tbl.append({
            "param": param,
            "error": "Sorry, still got nothing..."
        })

        return pe_tbl

    def _del_uslt_tags (self, file):

        tags_to_del = []

        for key in file.keys():
            if key[0:4] == "USLT":
                tags_to_del.append(key)

        for key in tags_to_del:
            file.pop(key)

    def get_lrc (self, file_list):

        track_name = None
        artist_name = None
        album_name = None
        duration = None

        file_stem = None

        for file_path in file_list:

            file = ID3(file_path)

            file_stem = os.path.splitext(os.path.basename(file_path))[0]

            Logger(file_path)
            Logger("Querying for " + file["TIT2"].text[0] + " - " + file["TPE1"].text[0] + "...")

            Logger("Fixing artists...")
            self._fix_artist(file)
            Logger("Deleting other USLT tags...")
            self._del_uslt_tags(file)

            track_name = file["TIT2"].text[0]
            artist_name = file["TPE1"].text[0]
            album_name = file["TALB"].text[0]
            duration = str(int(int(file["TLEN"].text[0]) / 1000))

            pe_tbl = self._create_pe_tbl(
                track_name,
                artist_name,
                album_name,
                duration
            )

            synced = None
            plain = None
            response = None

            for pe in pe_tbl:
                res = self._query_lrclib(pe["param"])

                if synced is None:
                    synced = res[0]

                if plain is None:
                    plain = res[1]

                response = res[2]
                if synced is None or plain is None:
                    Logger(pe["error"])
                else:
                    break

            if response is not None:
                # TODO: give proper file names instead to slamming file_stem
                with open(self.lrc_dir + "/json/" + file_stem + ".json", "w") as tmp_file:
                    tmp_file.write(response.text)
            else:
                Logger("No response at all, weird...", "WARN")

            if synced is not None:
                file.add(USLT(text = synced, desc = "synced"))
                with open(self.lrc_dir + "/lyrics/" + file_stem + ".lrc", "w") as tmp_file:
                    tmp_file.write(synced)
                    tmp_file.write("\n")
            else:
                Logger("Haven't got the synced lyrics...")

                if plain is not None:
                    file.add(USLT(text = plain, desc = "plain"))

            if plain is not None:
                with open(self.lrc_dir + "/plain/" + file_stem + ".lrc", "w") as tmp_file:
                    tmp_file.write(plain)
                    tmp_file.write("\n")
            else:
                Logger("Haven't got the plain lyrics...")

            file.save()

def parse_config():

    global Config_Dir
    global Music_Dir
    global Lyrics_Dir
    global Api_Id
    global Api_Hash

    Config_Dir = os.path.expandvars(Config_Dir)

    config_file = Config_Dir + "/config.ini"
    if not os.path.isfile(config_file):
        print("Config file is not present: " + config_file)
        print("Inorder to sdl to work, you need the Telegram Api Id and Hash")
        print("Exiting...")
        exit()

    config = configparser.ConfigParser()
    config.read(config_file)

    Music_Dir = os.path.expandvars(config["download"]["MusicDir"])

    if not os.path.isdir(Music_Dir):
        print("Directory doesn't exists: " + Music_Dir)
        print("Please make sure you have specified the right directory to download files.")
        print("Exiting...")
        exit()

    Lyrics_Dir = os.path.expandvars(config["download"]["LyricsDir"])

    if not os.path.isdir(Lyrics_Dir):
        print("Directory doesn't exists: " + Lyrics_Dir)
        print("Please make sure you have specified the right directory to download lyrics.")
        print("Exiting...")
        exit()

    Api_Id = int(config["telegram.api"]["Id"])
    Api_Hash = config["telegram.api"]["Hash"]


def download():

    pat = re.compile("^(https://open\.spotify\.com/([^/]+)/.{22})(\?)?(.*)$")

    query = ""
    downloaded_list = None

    if len(sys.argv) == 2 and (sys.argv[1] == "--clip" or sys.argv[1] == "-c"):
        clip = subprocess.Popen(
            ["termux-clipboard-get"], stdout = subprocess.PIPE
        )

        clip = clip.stdout.read().decode()

        mat = pat.match(clip)

        if mat is not None:

            url_type = None

            grps = mat.groups()

            if grps[1] == "album":
                url_type = "album"
            elif grps[1] == "track":
                url_type = "track"
            elif grps[1] == "playlist":
                url_type = "playlist"
            else:
                Logger("Currently only albums and tracks can be downloaded, exiting...")
                Logger("Clipboard contents: \"" + clip + "\"")
                exit()
        else:
            Logger("Clipboard does not contain a valid url, exiting...")
            Logger("Clipboard contents: \"" + clip + "\"")
            exit()

        sdl = SpotDownload(Config_Dir + "/anon", Api_Id, Api_Hash)
        downloaded_list = sdl.download([(grps[0], url_type)])
    else:
        if len(sys.argv) > 1:

            query = sys.argv[1]

            for arg in sys.argv[2:]:
                query = query + " " + arg
        else:
            print("Query: ", end = "")
            query = input()

        if query == "":
            Logger("No query, exiting...")
            exit()

        squery = SpotQuery(query)

        if squery.gen_result() is None:
            Logger("No selections were generated, exiting...")
            exit()

        sdl = SpotDownload(Config_Dir + "/anon", Api_Id, Api_Hash)
        downloaded_list = sdl.download([(squery.get_url(), squery.get_type())])

    lrc = SpotLrc(Lyrics_Dir)
    lrc.get_lrc(downloaded_list)

    return

# https://open.spotify.com/track/7nHQjVpEncX7NEdA2G6kU1
# https://open.spotify.com/track/7nHQjVpEncX7NEdA2G6kU1


# main()

def attach_lrc ():

    fzf = FzfPrompt()

    files = [file for file in os.listdir(Music_Dir) if file[-4:] == ".mp3"]
    files.sort(key = lambda x: os.path.getmtime(os.path.join(Music_Dir, x)))

    selected = [os.path.join(Music_Dir, file) for file in fzf.prompt(files, "--tac -m")]

    lrc = SpotLrc(Lyrics_Dir)
    lrc.get_lrc(selected)

parse_config()

# sq = SpotQuery("taylor swift songs")
sdl = SpotClient(Config_Dir + "/anon", Api_Id, Api_Hash)

print(sdl.connect())

### if len(sys.argv) == 2 and (sys.argv[1] == "--lrc" or sys.argv[1] == "-l"):
###     attach_lrc()
### else:
###     download()

# sdl = SpotDownload(Config_Dir + "/anon", Api_Id, Api_Hash)
# downloaded_list = sdl.download(
#     [("https://open.spotify.com/playlist/2oyDrQfkkSMdyXPXKKHm1t", "playlist")]
# )

# https://open.spotify.com/track/2Fxmhks0bxGSBdJ92vM42m
# lrc = SpotLrc(".")
# lrc.get_lrc(["/data/data/com.termux/files/home/storage/shared/Music/sdl/Emei - Scatterbrain.mp3"])
